/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Author: Sergei Parshev (@sparshev)

package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/adobe/aquarium-fish/lib/auth"
	"github.com/adobe/aquarium-fish/lib/build"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

const (
	rbacPackage = "aquarium.v2"
	rbacField   = "access_control"

	usage = "Aquarium Permission generator plugin.\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

// Permission represents a permission that can be granted to roles
type Permission struct {
	Resource string
	Action   string
	Comment  string
}

var serviceMethodConstantsTmpl = template.Must(template.New("service_method_constants").Parse(`/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-permissions. DO NOT EDIT.

package auth

// Service and Method constants
const (
{{- range $serviceName, $methods := .Services }}
	// {{ $serviceName }} service constants
	{{- range $idx, $method := $methods }}
	{{- $constName := print $serviceName $method }}
	{{- if eq $method "" }}
		{{- $method = $serviceName }}
	{{- end }}
	{{ $constName }} = "{{ $method }}"
	{{- end }}
{{ end }}
)

{{- if gt (len .AuthExcluded) 0 }}
// Auth-excluded service-methods
var authExcluded = map[string][]string{
	{{- range $serviceName, $methods := .AuthExcluded }}
	"{{ $serviceName }}": {
		{{- range $methods }}
		"{{ . }}",
		{{- end }}
	},
	{{ end }}
}

// IsEcludedFromAuth helps connectrpc to exclude methods from Auth validation
func IsEcludedFromAuth(service, method string) bool {
	if methods, ok := authExcluded[service]; ok {
		for _, m := range methods {
			if m == method {
				return true
			}
		}
	}
	return false
}{{ end }}
{{- if gt (len .RbacExcluded) 0 }}

// RBAC-excluded service-methods
var rbacExcluded = map[string][]string{
	{{- range $serviceName, $methods := .RbacExcluded }}
	"{{ $serviceName }}": {
		{{- range $methods }}
		"{{ . }}",
		{{- end }}
	},
	{{ end }}
}

// IsEcludedFromRBAC helps connectrpc to exclude methods from RBAC validation
func IsEcludedFromRBAC(service, method string) bool {
	if methods, ok := rbacExcluded[service]; ok {
		for _, m := range methods {
			if m == method {
				return true
			}
		}
	}
	return false
}{{ end }}
`))

var combinedPermissionsTmpl = template.Must(template.New("combined_permissions").Parse(`/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-permissions. DO NOT EDIT.

package auth

import (
	typesv2 "github.com/adobe/aquarium-fish/lib/types/aquarium/v2"
)

// All available permissions per role
var rolePermissions = map[string][]typesv2.Permission{
	{{- range $role, $perms := . }}
	"{{ $role }}": {
		{{- $lastResource := "" }}
		{{- range $perms }}
		{{- if ne $lastResource .Resource }}
		{{- if ne $lastResource "" }}
		{{ end }}
		// {{ .Resource }}
		{{- $lastResource = .Resource }}
		{{- end }}
		{Resource: {{ .Resource }}, Action: {{ .Resource }}{{ .Action }}}, // {{ .Comment }}
		{{- end }}
	},
	{{- end }}
}

// GetRolePermissions returns a map of all possible permissions for all known roles
func GetRolePermissions() map[string][]typesv2.Permission {
	return rolePermissions
}
`))

func processGrpcPermissions(plugin *protogen.Plugin) (map[string][]string, map[string][]Permission) {
	serviceMethods := make(map[string][]string)
	uniqueRoles := []string{auth.AdminRoleName}
	rolePermissions := make(map[string][]Permission)

	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}

		for _, service := range f.Services {
			svcName := service.GoName
			svcMethods := []string{""}

			for _, method := range service.Methods {
				opts, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
				var roles []string
				var additionalActions []string
				svcMethod := method.GoName
				if ok {
					ext := proto.GetExtension(opts, aquariumv2.E_AccessControl)
					ac, ok := ext.(*aquariumv2.RoleBasedAccessControl)

					if !ok || ac == nil {
						// If there is no AccessControl specified - assign it to Administrator
						roles = []string{auth.AdminRoleName} // Default role
					}
					if ac != nil {
						if ac.GetAllowUnauthenticated() {
							// If allow_unauthenticated is set - skip both auth & rbac entirely
							svcMethod = "--" + svcMethod
						} else if ac.GetNoPermissionNeeded() {
							// If no_permission_needed is set - skipping roles processing for method
							svcMethod = "-" + svcMethod
						} else {
							// Administrator as default
							roles = []string{auth.AdminRoleName} // Default role
							for _, role := range ac.GetAllowedRoles() {
								if !slices.Contains(roles, role) {
									roles = append(roles, role)
								}
								if !slices.Contains(uniqueRoles, role) {
									uniqueRoles = append(uniqueRoles, role)
								}
							}
						}
						// Additional actions
						for _, action := range ac.GetAdditionalActions() {
							additionalActions = append(additionalActions, action)
							if !slices.Contains(svcMethods, action) {
								svcMethods = append(svcMethods, action)
							}
						}
					}
				} else {
					// If there is no AccessControl specified - assign it to Administrator
					roles = []string{auth.AdminRoleName} // Default role
				}

				svcMethods = append(svcMethods, svcMethod)

				// Add permissions for each role
				for _, role := range roles {
					perm := Permission{
						Resource: svcName,
						Action:   method.GoName,
						Comment:  "gRPC",
					}
					rolePermissions[role] = append(rolePermissions[role], perm)

					// Allowing admin role to use additional actions as well
					if role == auth.AdminRoleName {
						for _, action := range additionalActions {
							perm = Permission{
								Resource: svcName,
								Action:   action,
								Comment:  "gRPC additional",
							}
							rolePermissions[role] = append(rolePermissions[role], perm)
						}
					}
				}
			}

			// Sort methods to ensure they will be in order
			sort.Strings(svcMethods)
			serviceMethods[svcName] = svcMethods
		}
	}

	return serviceMethods, rolePermissions
}

func generatePermissionFiles(grpcServices map[string][]string, grpcRoles map[string][]Permission) error {
	// Generate gRPC-specific permissions
	if err := generateServiceMethodConstants(grpcServices, "grpc"); err != nil {
		return err
	}

	// Generate combined permissions
	return generateCombinedPermissions(grpcRoles)
}

func generateServiceMethodConstants(services map[string][]string, suffix string) error {
	// Add services methods with "-" prefix to RBAC exclusion
	// It's used on ConnectRPC side
	authExcluded := make(map[string][]string)
	rbacExcluded := make(map[string][]string)
	for service, methods := range services {
		for i, method := range methods {
			if strings.HasPrefix(method, "--") {
				// Two minuses before the method means it's excluded from both Auth & RBAC
				if _, ok := authExcluded[service]; !ok {
					authExcluded[service] = []string{}
				}
				noPrefixMethod := method[2:]
				authExcluded[service] = append(authExcluded[service], noPrefixMethod)
				rbacExcluded[service] = append(rbacExcluded[service], noPrefixMethod)
				methods[i] = noPrefixMethod
				services[service] = methods
			} else if strings.HasPrefix(method, "-") {
				// One minus - means method excluded from RBAC
				if _, ok := rbacExcluded[service]; !ok {
					rbacExcluded[service] = []string{}
				}
				noPrefixMethod := method[1:]
				rbacExcluded[service] = append(rbacExcluded[service], noPrefixMethod)
				methods[i] = noPrefixMethod
				services[service] = methods
			}
		}
	}

	// Execute template
	g := &bytes.Buffer{}
	err := serviceMethodConstantsTmpl.Execute(g, map[string]any{
		"Services":     services,
		"AuthExcluded": authExcluded,
		"RbacExcluded": rbacExcluded,
	})
	if err != nil {
		return fmt.Errorf("Error executing gRPC template: %v", err)
	}

	outFile := filepath.Join("lib", "auth", "permissions_"+suffix+".gen.go")
	if err := os.WriteFile(outFile, g.Bytes(), 0644); err != nil { //nolint:gosec // G306 - No need to tighten 0644 further for autogenerated code
		return fmt.Errorf("Error writing service/method constants file %s: %v\n", outFile, err)
	} else {
		if err = formatGoFile(outFile); err != nil {
			return fmt.Errorf("Error formatting service/method constants file %s: %v\n", outFile, err)
		}
	}

	return nil
}

func generateCombinedPermissions(grpcRoles map[string][]Permission) error {
	// Merge roles and permissions
	combinedRoles := make(map[string][]Permission)

	// Add gRPC roles
	for role, perms := range grpcRoles {
		combinedRoles[role] = append(combinedRoles[role], perms...)
	}

	// Sort permissions for each role
	for role, perms := range combinedRoles {
		sort.Slice(perms, func(i, j int) bool {
			if perms[i].Resource == perms[j].Resource {
				return perms[i].Action < perms[j].Action
			}
			return perms[i].Resource < perms[j].Resource
		})
		combinedRoles[role] = perms
	}

	g := &bytes.Buffer{}
	err := combinedPermissionsTmpl.Execute(g, combinedRoles)
	if err != nil {
		return fmt.Errorf("Error executing combined template: %v", err)
	}

	outFile := filepath.Join("lib", "auth", "permissions.gen.go")
	if err := os.WriteFile(outFile, g.Bytes(), 0644); err != nil { //nolint:gosec // G306 - No need to tighten 0644 further for autogenerated code
		return fmt.Errorf("Error writing combined permissions file %s: %v\n", outFile, err)
	} else {
		if err = formatGoFile(outFile); err != nil {
			return fmt.Errorf("Error formatting combined permissions file %s: %v", outFile, err)
		}
	}

	return nil
}

// formatGoFile formats a Go file using gofmt
func formatGoFile(filename string) error {
	cmd := exec.Command("gofmt", "-w", filename)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("gofmt failed: %v\n%s", err, output)
	}
	return nil
}

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Fprintln(os.Stdout, build.Version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}

	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
		plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023

		// Process gRPC permissions
		grpcServices, grpcRoles := processGrpcPermissions(plugin)

		// Merge roles and generate files
		return generatePermissionFiles(grpcServices, grpcRoles)
	})
}
