/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

package main

import (
	"bytes"
	//"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"text/template"

	"github.com/getkin/kin-openapi/openapi3"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/adobe/aquarium-fish/lib/auth"
	"github.com/adobe/aquarium-fish/lib/build"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/gen/proto/aquarium/v2"
)

const (
	rbacPackage = "aquarium.v2"
	rbacField   = "access_control"

	usage = "Aquarium Permission generator plugin.\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

// Permission represents a permission that can be granted to roles
type Permission struct {
	Resource string
	Action   string
	Comment  string
}

var serviceMethodConstantsTmpl = template.Must(template.New("service_method_constants").Parse(`/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-permissions. DO NOT EDIT.

package auth

// Service and Method constants
const (
{{- range $serviceName, $methods := .Services }}
	// {{ $serviceName }} service constants
	{{- range $methods }}
	{{ $serviceName }}{{ . }} = "{{ $serviceName }}{{ . }}"
	{{- end }}
{{ end }}
)
`))

var combinedPermissionsTmpl = template.Must(template.New("combined_permissions").Parse(`/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-permissions. DO NOT EDIT.

package auth

import (
	"github.com/adobe/aquarium-fish/lib/openapi/types"
)

// All available permissions per role
var rolePermissions = map[string][]types.Permission{
	{{- range $role, $perms := . }}
	"{{ $role }}": {
		{{- $lastResource := "" }}
		{{- range $perms }}
		{{- if ne $lastResource .Resource }}
		{{- if ne $lastResource "" }}
		{{ end }}
		// {{ .Resource }}
		{{- $lastResource = .Resource }}
		{{- end }}
		{Resource: {{ .Resource }}, Action: {{ .Resource }}{{ .Action }}}, // {{ .Comment }}
		{{- end }}
	},
	{{- end }}
}

// GetRolePermissions returns a map of all possible permissions for all known roles
func GetRolePermissions() map[string][]types.Permission {
	return rolePermissions
}
`))

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Fprintln(os.Stdout, build.Version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}

	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
		plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023

		// Process gRPC permissions
		grpcServices, grpcRoles := processGrpcPermissions(plugin)

		// Process OpenAPI permissions if available
		openapiServices, openapiRoles := processOpenAPIPermissions(plugin, grpcServices)

		// Merge roles and generate files
		return generatePermissionFiles(grpcServices, openapiServices, grpcRoles, openapiRoles)
	})
}

func processGrpcPermissions(plugin *protogen.Plugin) (map[string][]string, map[string][]Permission) {
	serviceMethods := make(map[string][]string)
	uniqueRoles := []string{auth.AdminRoleName}
	rolePermissions := make(map[string][]Permission)

	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}

		for _, service := range f.Services {
			svcName := service.GoName
			svcMethods := []string{""}

			for _, method := range service.Methods {
				opts := method.Desc.Options().(*descriptorpb.MethodOptions)
				ext := proto.GetExtension(opts, aquariumv2.E_AccessControl)
				ac, ok := ext.(*aquariumv2.RoleBasedAccessControl)

				var roles []string
				if !ok || ac == nil {
					roles = []string{auth.AdminRoleName} // Default role
				}
				if ac != nil && len(ac.AllowedRoles) > 0 {
					roles = []string{auth.AdminRoleName} // Default role
					for _, role := range ac.AllowedRoles {
						if !slices.Contains(roles, role) {
							roles = append(roles, role)
						}
						if !slices.Contains(uniqueRoles, role) {
							uniqueRoles = append(uniqueRoles, role)
						}
					}
				}

				svcMethods = append(svcMethods, method.GoName)

				// Add permissions for each role
				for _, role := range roles {
					perm := Permission{
						Resource: svcName,
						Action:   method.GoName,
						Comment:  "gRPC",
					}
					rolePermissions[role] = append(rolePermissions[role], perm)
				}
			}

			// Sort methods to ensure they will be in order
			sort.Strings(svcMethods)
			serviceMethods[svcName] = svcMethods
		}
	}

	return serviceMethods, rolePermissions
}

func processOpenAPIPermissions(plugin *protogen.Plugin, knownServiceMethods map[string][]string) (map[string][]string, map[string][]Permission) {
	serviceMethods := make(map[string][]string)
	rolePermissions := make(map[string][]Permission)

	// Check if OpenAPI spec exists
	specPath := "docs/openapi.yaml"
	if _, err := os.Stat(specPath); os.IsNotExist(err) {
		return serviceMethods, rolePermissions
	}

	// Load OpenAPI spec
	loader := openapi3.NewLoader()
	doc, err := loader.LoadFromFile(specPath)
	if err != nil {
		plugin.Error(fmt.Errorf("WARN: Failed to load OpenAPI spec: %v", err))
		return serviceMethods, rolePermissions
	}

	// Process all paths
	for path, pathItem := range doc.Paths.Map() {
		if pathItem == nil {
			continue
		}

		processOperation := func(method string, op *openapi3.Operation) {
			if op == nil {
				return
			}

			// Get x-rbac extension
			rbacExt := op.Extensions["x-rbac"]
			if rbacExt == nil {
				return
			}

			// Parse x-rbac extension
			rbacMap := map[string][]string{}
			//if err := json.Unmarshal(rbacExt.(json.RawMessage), &rbacMap); err != nil {
			rbacMapPre, ok := rbacExt.(map[string]any)
			if !ok {
				return
			}
			for role, actionsPre := range rbacMapPre {
				if actionsPreList, ok := actionsPre.([]any); ok {
					actions := []string{}
					for _, actionPre := range actionsPreList {
						if action, ok := actionPre.(string); ok {
							actions = append(actions, action)
						}
					}
					if len(actions) > 0 {
						rbacMap[role] = actions
					}
				}
			}

			if len(rbacMap) == 0 {
				rbacMap = map[string][]string{
					auth.AdminRoleName: {method},
				}
			}

			if len(op.Tags) < 1 {
				plugin.Error(fmt.Errorf("ERROR: Unable to find Resource specifying tag for path %q method %q", path, method))
				return
			}

			serviceName := op.Tags[0] + "Service"
			if _, ok := serviceMethods[serviceName]; !ok {
				if _, ok = knownServiceMethods[serviceName]; !ok {
					// Adding service itself to the constants
					serviceMethods[serviceName] = []string{""}
				} else {
					// Not adding service since it's already defined in known services
					serviceMethods[serviceName] = []string{}
				}
			}

			// Process each role and its permissions
			for role, actions := range rbacMap {
				if len(actions) == 0 && op.OperationID != "" {
					actions = []string{op.OperationID}
				}

				for _, action := range actions {
					if _, ok := knownServiceMethods[serviceName]; !ok || !slices.Contains(knownServiceMethods[serviceName], action) {
						if !slices.Contains(serviceMethods[serviceName], action) {
							serviceMethods[serviceName] = append(serviceMethods[serviceName], action)
						}
					}
					rolePermissions[role] = append(rolePermissions[role], Permission{
						Resource: serviceName,
						Action:   action,
						Comment:  "OpenAPI",
					})
				}
			}
		}

		processOperation("Get", pathItem.Get)
		processOperation("Create", pathItem.Post)
		processOperation("Update", pathItem.Put)
		processOperation("Delete", pathItem.Delete)
	}

	// Sort methods to ensure they will be in order
	for role := range serviceMethods {
		sort.Strings(serviceMethods[role])
	}

	return serviceMethods, rolePermissions
}

func generatePermissionFiles(grpcServices, openapiServices map[string][]string, grpcRoles, openapiRoles map[string][]Permission) error {
	// Generate gRPC-specific permissions
	if err := generateServiceMethodConstants(grpcServices, "grpc"); err != nil {
		return err
	}

	// Generate OpenAPI-specific permissions
	if err := generateServiceMethodConstants(openapiServices, "openapi"); err != nil {
		return err
	}

	// Generate combined permissions
	return generateCombinedPermissions(grpcRoles, openapiRoles)
}

func generateServiceMethodConstants(services map[string][]string, suffix string) error {
	g := &bytes.Buffer{}
	err := serviceMethodConstantsTmpl.Execute(g, map[string]any{
		"Services": services,
	})
	if err != nil {
		return fmt.Errorf("Error executing gRPC template: %v", err)
	}

	outFile := filepath.Join("lib", "auth", "permissions_"+suffix+".gen.go")
	if err := os.WriteFile(outFile, g.Bytes(), 0644); err != nil {
		return fmt.Errorf("Error writing service/method constants file %s: %v\n", outFile, err)
	} else {
		if err = formatGoFile(outFile); err != nil {
			return fmt.Errorf("Error formatting service/method constants file %s: %v\n", outFile, err)
		}
	}

	return nil
}

func generateCombinedPermissions(grpcRoles, openapiRoles map[string][]Permission) error {
	// Merge roles and permissions
	combinedRoles := make(map[string][]Permission)

	// Add gRPC roles
	for role, perms := range grpcRoles {
		combinedRoles[role] = append(combinedRoles[role], perms...)
	}

	// Add OpenAPI roles
	for role, perms := range openapiRoles {
		// Skipping the existing permissions to not duplicate
		if existingPerms, ok := combinedRoles[role]; ok {
			for _, perm := range perms {
				found := false
				for existingIndex, existingPerm := range existingPerms {
					if existingPerm.Resource == perm.Resource && existingPerm.Action == perm.Action {
						if !strings.HasSuffix(existingPerm.Comment, perm.Comment) {
							// Appending comment of existing one with the proposed one
							combinedRoles[role][existingIndex].Comment = existingPerm.Comment + ", " + perm.Comment
						}
						found = true
						break
					}
				}
				if !found {
					combinedRoles[role] = append(combinedRoles[role], perm)
				}
			}
		} else {
			combinedRoles[role] = append(combinedRoles[role], perms...)
		}
	}

	// Sort permissions for each role
	for role, perms := range combinedRoles {
		sort.Slice(perms, func(i, j int) bool {
			if perms[i].Resource == perms[j].Resource {
				return perms[i].Action < perms[j].Action
			}
			return perms[i].Resource < perms[j].Resource
		})
		combinedRoles[role] = perms
	}

	g := &bytes.Buffer{}
	err := combinedPermissionsTmpl.Execute(g, combinedRoles)
	if err != nil {
		return fmt.Errorf("Error executing combined template: %v", err)
	}

	outFile := filepath.Join("lib", "auth", "permissions.gen.go")
	if err := os.WriteFile(outFile, g.Bytes(), 0644); err != nil {
		return fmt.Errorf("Error writing combined permissions file %s: %v\n", outFile, err)
	} else {
		if err = formatGoFile(outFile); err != nil {
			return fmt.Errorf("Error formatting combined permissions file %s: %v", outFile, err)
		}
	}

	return nil
}

// formatGoFile formats a Go file using gofmt
func formatGoFile(filename string) error {
	cmd := exec.Command("gofmt", "-w", filename)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("gofmt failed: %v\n%s", err, output)
	}
	return nil
}
