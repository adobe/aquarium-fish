/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Author: Sergei Parshev (@sparshev)

package main

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/adobe/aquarium-fish/lib/build"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

const (
	usage = "Aquarium Streaming generator plugin.\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

// ServiceInfo represents information about a service for streaming
type ServiceInfo struct {
	Name     string       // Service name (e.g., "ApplicationService")
	Methods  []MethodInfo // Methods in the service
	Variable string       // Variable name for service instance (e.g., "applicationService")
}

// MethodInfo represents information about a method for streaming
type MethodInfo struct {
	Name             string // Method name (e.g., "List", "Get", "Create")
	RequestType      string // Full request type name (e.g., "ApplicationServiceListRequest")
	ResponseType     string // Full response type name (e.g., "ApplicationServiceListResponse")
	HasPostProcessor bool   // Whether this method has custom post-processing
	CachePermissions bool   // Whether to cache permissions for this method
}

// SubscriptionInfo represents a subscribable message type
type SubscriptionInfo struct {
	MessageType      string // Message name (e.g., "ApplicationState")
	SubscriptionType string // Subscription type enum (e.g., "SUBSCRIPTION_TYPE_APPLICATION_STATE")
	PermissionMethod string // RBAC permission method (e.g., "ApplicationServiceGetStateAll")
	CustomHandler    string // Custom handler method if any

	// Additional fields for code generation
	TypesPackageType string // Full type name (e.g., "*typesv2.ApplicationState")
	ChannelFieldName string // Channel field name in subscription (e.g., "stateChannel")
	SafeSendMethod   string // Safe send method name (e.g., "safeSendToStateChannel")
	ConversionMethod string // Conversion method (e.g., "ToApplicationState")
	DatabaseMethod   string // Database subscription method (e.g., "SubscribeApplicationState")
	RelayMethodName  string // Generic relay method name (e.g., "relayApplicationStateNotifications")
}

// TemplateData represents all data needed for code generation
type TemplateData struct {
	Services      []ServiceInfo
	Subscriptions []SubscriptionInfo
}

var streamingTemplate = `/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-streaming. DO NOT EDIT.

package rpc

// This file contains generated routing logic for streaming service
// It extends the main StreamingService with auto-generated request routing methods

import (
	"context"
	"fmt"
	"strings"
	"time"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/adobe/aquarium-fish/lib/auth"
	"github.com/adobe/aquarium-fish/lib/log"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
	rpcutil "github.com/adobe/aquarium-fish/lib/rpc/util"
	typesv2 "github.com/adobe/aquarium-fish/lib/types/aquarium/v2"
)

// subChannels is used to store channels for subscriptions communications
type subChannels struct {
{{- range .Subscriptions }}
	{{ .ChannelFieldName }} chan {{ .TypesPackageType }}
{{- end }}
}

// requestTypeMapping maps request types to service and method names for RBAC
type serviceMethodInfo struct {
	service string
	method  string
}

var requestTypeMapping = map[string]serviceMethodInfo{
{{- range .Services }}
{{- $service := . }}
{{- range .Methods }}
	"{{ $service.Name }}{{ .Name }}Request": {auth.{{ $service.Name }}, auth.{{ $service.Name }}{{ .Name }}},
{{- end }}
{{- end }}
}

{{- range .Services }}
{{- $service := . }}
// route{{ .Name }}Request routes {{ .Name | toLower }} service requests
func (s *StreamingService) route{{ .Name }}Request(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
{{- range .Methods }}
	case "{{ $service.Name }}{{ .Name }}Request":
		var req aquariumv2.{{ $service.Name }}{{ .Name }}Request
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.{{ $service.Variable }}.{{ .Name }}(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}
{{- if and (eq $service.Name "ApplicationService") (eq .Name "Create") }}
		// Cache permission for the owner (creator) of the application
		if resp.Msg.Status && resp.Msg.Data != nil {
			userName := rpcutil.GetUserName(ctx)
			appUID := stringToUUID(resp.Msg.Data.Uid)
			s.permissionCache.GrantAccess(userName, appUID)
			logger := log.WithFunc("rpc", "route{{ $service.Name }}Request")
			logger.Debug("Streaming: Cached permission for app creator", "user", userName, "app_uid", appUID)
		}
{{- end }}

		return anypb.New(resp.Msg)
{{- end }}
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported {{ .Name | toLower }} request type: %s", requestType))
	}
}

{{- end }}

// routeRequest routes a request to the appropriate service handler
func (s *StreamingService) routeRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	logger := log.WithFunc("rpc", "routeRequest")
	logger.Debug("Streaming: Routing request type", "req_type", requestType)

	// Route to the appropriate service using generated routing methods
	switch {
{{- range .Services }}
	case strings.HasPrefix(requestType, "{{ .Name }}"):
		return s.route{{ .Name }}Request(ctx, requestType, requestData)
{{- end }}
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported request type: %s", requestType))
	}
}

// Subscription-related helper methods
{{- range .Subscriptions }}
// {{ .RelayMethodName }} safely relays {{ .MessageType | toLower }} notifications with buffer overflow protection
func (s *StreamingService) {{ .RelayMethodName }}(ctx context.Context, subscriptionID string, sub *subscription, dbChannel <-chan {{ .TypesPackageType }}) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "{{ .RelayMethodName }}").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("{{ .MessageType }} relay goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("{{ .MessageType }} relay stopping due to context cancellation")
			return
		case obj, ok := <-dbChannel:
			if !ok {
				logger.Debug("{{ .MessageType }} relay stopping due to closed database channel")
				return
			}

			// Check if client is already overflowing - skip notification to prevent further overflow
			if sub.isClientOverflowing() {
				logger.Debug("Skipping {{ .MessageType | toLower }} notification due to client overflow")
				continue
			}

			// Try to send safely - if this returns true, client should be disconnected
			if shouldDisconnect := !sub.{{ .SafeSendMethod }}(obj); shouldDisconnect {
				logger.Error("Disconnecting client due to excessive buffer overflow")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

{{- end }}

// setupChannels sets the channels for the database changes
func (s *StreamingService) setupChannels() *subChannels {
	return &subChannels{
{{- range .Subscriptions }}
		{{ .ChannelFieldName }}: make(chan {{ .TypesPackageType }}, 100),
{{- end }}
	}
}

// listenChannels listen for database channels
func (s *StreamingService) listenChannels(sub *subscription, ctx, subCtx context.Context) {
	logger := log.WithFunc("rpc", "listenChannels").With("subs_uid", sub.id)
	// Signal completion when this goroutine exits
	defer sub.listenChannelsWg.Done()

	defer func() {
		if r := recover(); r != nil {
			logger.Error("goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-subCtx.Done():
			logger.Debug("stopping due to subscription context cancellation", "subs_uid", sub.id)
			return
		case <-ctx.Done():
			logger.Debug("stopping due to request context cancellation", "subs_uid", sub.id)
			return

{{- range .Subscriptions }}
		case msg := <-sub.channels.{{ .ChannelFieldName }}:
			if s.shouldSendObject(sub, aquariumv2.{{ .SubscriptionType }}, msg) {
				logger.Debug("Sending {{ .MessageType }} notification for Application UID", "app_uid", msg.ApplicationUid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.{{ .SubscriptionType }}, aquariumv2.ChangeType_CHANGE_TYPE_CREATED, msg.{{ .ConversionMethod }}()); err != nil {
					logger.Error("Error sending {{ .MessageType }} update", "err", err)
				}
			} else {
				logger.Debug("Skipping {{ .MessageType }} notification for user", "user", sub.userName)
			}
{{- end }}
		}
	}
}

// Close will close all the channels
func (s *subChannels) Close() {
{{- range .Subscriptions }}
	close(s.{{ .ChannelFieldName }})
{{- end }}
}

// setupSubscriptions sets up database subscriptions and relay goroutines
func (s *StreamingService) setupSubscriptions(subCtx context.Context, subscriptionID string, sub *subscription, subscriptionTypes []aquariumv2.SubscriptionType) {
	logger := log.WithFunc("rpc", "setupSubscriptions").With("subs_uid", sub.id)
	for _, subType := range subscriptionTypes {
		switch subType {
{{- range .Subscriptions }}
		case aquariumv2.{{ .SubscriptionType }}:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan {{ .TypesPackageType }}, 100)
			s.fish.DB().{{ .DatabaseMethod }}(subCtx, dbChannel)
			logger.Debug("Subscribed to {{ .MessageType }} changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.{{ .RelayMethodName }}(subCtx, subscriptionID, sub, dbChannel)

{{- end }}
		}
	}
}

// shouldSendObject checks if an object should be sent to the subscriber based on filters and permissions
func (s *StreamingService) shouldSendObject(sub *subscription, objectType aquariumv2.SubscriptionType, obj any) bool {
	// Check if this subscription type is requested
	found := false
	for _, subType := range sub.subscriptions {
		if subType == objectType {
			found = true
			break
		}
	}
	if !found {
		return false
	}

	// Apply filters based on object type
	switch objectType {
{{- range .Subscriptions }}
	case aquariumv2.{{ .SubscriptionType }}:
		if typedObj, ok := obj.({{ .TypesPackageType }}); ok {
			return s.shouldSendApplicationObject(sub, typedObj.ApplicationUid, objectType)
		}
{{- end }}
	}

	return true
}

{{- range .Subscriptions }}
// shouldSend{{ .MessageType }} checks if {{ .MessageType | toLower }} should be sent to subscriber
func (s *StreamingService) shouldSend{{ .MessageType }}(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.{{ .SubscriptionType }} {
			return true
		}
	}
	return false
}

{{- end }}

{{- range .Subscriptions }}
// safeSendTo{{ .MessageType }}Channel attempts to send to state channel with overflow detection
func (sub *subscription) safeSendTo{{ .MessageType }}Channel(msg {{ .TypesPackageType }}) bool {
	logger := log.WithFunc("rpc", "safeSendTo{{ .MessageType }}Channel").With("subs_uid", sub.id, "sub_user", sub.userName)
	select {
	case sub.channels.{{ .ChannelFieldName }} <- msg:
		sub.resetOverflow()
		return true
	case <-time.After(overflowTimeout):
		logger.Warn("{{ .MessageType }} channel send timeout (buffer overflow)")
		return sub.recordOverflow()
	default:
		logger.Warn("{{ .MessageType }} channel full (buffer overflow)")
		return sub.recordOverflow()
	}
}

{{- end }}

// getSubscriptionPermissionMethod returns the RBAC permission method for a subscription type
func (s *StreamingService) getSubscriptionPermissionMethod(subscriptionType aquariumv2.SubscriptionType) string {
	switch subscriptionType {
{{- range .Subscriptions }}
	case aquariumv2.{{ .SubscriptionType }}:
		return auth.{{ .PermissionMethod }}
{{- end }}
	default:
		return ""
	}
}
`

// Template helper functions
var templateFuncs = template.FuncMap{
	"toLower": func(s string) string {
		if len(s) == 0 {
			return ""
		}
		return strings.ToLower(s[:1]) + s[1:]
	},
}

// isStreamingService checks if a service should be included in streaming generation
func isStreamingService(serviceName string) bool {
	// Only include services that have corresponding fields in StreamingService
	supportedServices := []string{
		"ApplicationService",
		"LabelService",
		"NodeService",
		"UserService",
		"RoleService",
	}
	for _, supported := range supportedServices {
		if serviceName == supported {
			return true
		}
	}
	return false
}

// generateVariableName creates a variable name from service name
func generateVariableName(serviceName string) string {
	if len(serviceName) == 0 {
		return ""
	}
	return strings.ToLower(serviceName[:1]) + serviceName[1:]
}

// isRequestMessage checks if a message name ends with "Request"
func isRequestMessage(messageName string) bool {
	return strings.HasSuffix(messageName, "Request")
}

// isResponseMessage checks if a message name ends with "Response"
func isResponseMessage(messageName string) bool {
	return strings.HasSuffix(messageName, "Response")
}

// getResponseTypeName converts request type name to response type name
func getResponseTypeName(requestTypeName string) string {
	return strings.Replace(requestTypeName, "Request", "Response", 1)
}

// processServices processes protobuf services to extract streaming information
func processServices(plugin *protogen.Plugin) []ServiceInfo {
	var services []ServiceInfo

	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}

		for _, service := range f.Services {
			serviceName := service.GoName

			// Skip services that shouldn't be included in streaming
			if !isStreamingService(serviceName) {
				continue
			}

			var methods []MethodInfo

			for _, method := range service.Methods {
				// Skip streaming methods (bidirectional, server stream, client stream)
				if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
					continue
				}

				methodName := method.GoName
				requestTypeName := method.Input.GoIdent.GoName
				responseTypeName := method.Output.GoIdent.GoName

				// TODO: Add support for custom routing options via protobuf extensions
				var hasPostProcessor bool
				var cachePermissions bool

				// For now, detect special cases based on method names
				if methodName == "Create" && serviceName == "ApplicationService" {
					cachePermissions = true
				}

				methods = append(methods, MethodInfo{
					Name:             methodName,
					RequestType:      requestTypeName,
					ResponseType:     responseTypeName,
					HasPostProcessor: hasPostProcessor,
					CachePermissions: cachePermissions,
				})
			}

			if len(methods) > 0 {
				// Sort methods for consistent output
				sort.Slice(methods, func(i, j int) bool {
					return methods[i].Name < methods[j].Name
				})

				services = append(services, ServiceInfo{
					Name:     serviceName,
					Methods:  methods,
					Variable: generateVariableName(serviceName),
				})
			}
		}
	}

	// Sort services for consistent output
	sort.Slice(services, func(i, j int) bool {
		return services[i].Name < services[j].Name
	})

	return services
}

func toSnake(camel string) (snake string) {
	var b strings.Builder
	diff := 'a' - 'A'
	l := len(camel)
	for i, v := range camel {
		if v >= 'a' {
			b.WriteRune(v)
			continue
		}
		if (i != 0 || i == l-1) && ((i > 0 && rune(camel[i-1]) >= 'a') || (i < l-1 && rune(camel[i+1]) >= 'a')) {
			b.WriteRune('_')
		}
		b.WriteRune(v + diff)
	}
	return b.String()
}

func toLowerFirst(s string) string {
	if len(s) != 0 && (s[0] <= 'Z' && s[0] >= 'A') {
		return string(s[0]+32) + s[1:]
	}

	return s
}

// processSubscriptions processes protobuf messages to extract subscription information from extensions
func processSubscriptions(plugin *protogen.Plugin) []SubscriptionInfo {
	var subscriptions []SubscriptionInfo

	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		for _, message := range file.Messages {
			messageName := string(message.Desc.Name())

			opts, ok := message.Desc.Options().(*descriptorpb.MessageOptions)
			if ok {
				ext := proto.GetExtension(opts, aquariumv2.E_SubscribeConfig)
				ac, ok := ext.(*aquariumv2.SubscribeConfig)

				if ok && ac != nil {
					subscriptions = append(subscriptions, SubscriptionInfo{
						MessageType:      messageName,
						SubscriptionType: "SubscriptionType_SUBSCRIPTION_TYPE_" + strings.ToUpper(toSnake(messageName)),
						PermissionMethod: ac.GetPermissionCheck(),
						TypesPackageType: "*typesv2." + messageName,
						ChannelFieldName: toLowerFirst(messageName) + "Channel",
						SafeSendMethod:   "safeSendTo" + messageName + "Channel",
						ConversionMethod: "To" + messageName,
						DatabaseMethod:   "Subscribe" + messageName,
						RelayMethodName:  "relay" + messageName + "Notifications",
					})
				}
			}
		}
	}

	return subscriptions
}

// generateStreamingService generates the streaming service code
func generateStreamingService(plugin *protogen.Plugin) error {
	services := processServices(plugin)
	subscriptions := processSubscriptions(plugin)

	// Prepare template data
	templateData := TemplateData{
		Services:      services,
		Subscriptions: subscriptions,
	}

	// Create template with custom functions
	tmpl := template.Must(template.New("streaming_template").Funcs(templateFuncs).Parse(streamingTemplate))

	// Generate the file using template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Generate the file using protogen's file generation system
	filename := "streaming_service.gen.go"
	g := plugin.NewGeneratedFile(filename, "github.com/adobe/aquarium-fish/lib/rpc")

	// Write the generated content
	g.P(buf.String())

	return nil
}

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Fprintln(os.Stdout, build.Version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}

	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
		plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023

		return generateStreamingService(plugin)
	})
}
