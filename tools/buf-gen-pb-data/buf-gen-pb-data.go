/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Author: Sergei Parshev (@sparshev)

package main

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/adobe/aquarium-fish/lib/build"
)

const (
	usage = "Aquarium protobuf data generator plugin.\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

// DataField represents a field in the data struct
type DataField struct {
	Name         string // Field name in data struct
	Type         string // Go type in data struct
	OriginalName string // Original field name in protobuf
	IsRepeated   bool   // Whether the field is repeated (slice)
	IsOptional   bool   // Whether the field is optional
	IsMap        bool   // Whether the field is a map
	MapKeyType   string // For map fields, the key type
	MapValueType string // For map fields, the value type
}

// DataMessage represents a data struct for a protobuf message
type DataMessage struct {
	DataName     string      // Name of data struct
	OriginalName string      // Name of original protobuf struct
	ReceiverVar  string      // Receiver variable name
	Fields       []DataField // Fields in the data
}

// EnumData represents an enum type to be generated
type EnumData struct {
	Name         string           // Local enum name
	OriginalName string           // Original protobuf enum name
	Values       map[string]int32 // Enum values
}

// TypeAlias represents a type alias for a message UID
type TypeAlias struct {
	Name string // e.g., "ApplicationUID", "NodeUID"
}

// FileData represents all data needed for generating a file
type FileData struct {
	PackageName string
	Messages    []DataMessage
	Enums       []EnumData  // Enums used in this file
	TypeAliases []TypeAlias // Contains found type aliases
	HasUUIDs    bool        // Whether any message uses UUID
	HasTime     bool        // Whether any message uses time.Time
	HasJSON     bool        // Whether any message uses util.UnparsedJSON
}

var basicTemplate = `/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package {{.PackageName}}

import (
{{- if .HasJSON }}
	"encoding/json"
{{ end }}
{{- if .HasTime }}
	"time"
{{ end }}
{{- if .HasUUIDs }}
	"github.com/google/uuid"
{{ end }}
{{- if .HasJSON }}
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/structpb"
{{ end }}
{{- if .HasTime }}
	"google.golang.org/protobuf/types/known/timestamppb"
{{ end }}

{{- if .HasJSON }}
	"github.com/adobe/aquarium-fish/lib/util"
{{- end }}

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

{{range .Enums}}
// {{.Name}} mirrors the protobuf enum
type {{.Name}} int32

const (
{{- $enumName := .Name }}
{{- range $key, $value := .Values }}
	{{$key}} {{$enumName}} = {{$value}}
{{- end }}
)

{{end}}

{{- range .TypeAliases }}
type {{ .Name }} = uuid.UUID
{{- end }}

{{range .Messages}}
// {{.DataName}} is a data for {{.OriginalName}} without internal locks
type {{.DataName}} struct {
{{- range .Fields }}
	{{.Name}} {{if .IsOptional}}*{{end}}{{if .IsRepeated}}[]{{end}}{{.Type}} ` + "`json:\"{{.OriginalName}},omitempty\"`" + `
{{- end }}}

// From{{.OriginalName}} creates a {{.DataName}} from {{.OriginalName}}
func From{{.OriginalName}}(src *pbTypes.{{.OriginalName}}) {{.DataName}} {
	if src == nil {
		return {{.DataName}}{}
	}
	
	result := {{.DataName}}{}
{{- range .Fields }}
{{- if .IsMap }}
	// Convert map field {{.OriginalName}}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
		result.{{.Name}} = make({{.Type}})
		for k, v := range src.Get{{toCamelCase .OriginalName}}() {
{{- if eq .MapValueType "uuid.UUID" }}
			if uid, err := uuid.Parse(v); err == nil {
				result.{{.Name}}[k] = uid
			}
{{- else if eq .MapValueType "time.Time" }}
			if v != nil {
				result.{{.Name}}[k] = v.AsTime()
			}
{{- else if eq .MapValueType "util.UnparsedJSON" }}
			if v != nil {
				if data, err := protojson.Marshal(v); err == nil {
					result.{{.Name}}[k] = util.UnparsedJSON(data)
				}
			}
{{- else if isMessage .MapValueType $.Messages }}
			if v != nil {
				result.{{.Name}}[k] = From{{.MapValueType}}(v)
			}
{{- else if isEnum .MapValueType $.Enums }}
			result.{{.Name}}[k] = {{.MapValueType}}(v)
{{- else }}
			result.{{.Name}}[k] = v
{{- end }}
		}
	}
{{- else if eq .Type "uuid.UUID" }}
	if uid, err := uuid.Parse(src.Get{{toCamelCase .OriginalName}}()); err == nil {
		result.{{.Name}} = uid
	}
{{- else if eq .Type "time.Time"}}{{if .IsOptional }}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
		t := src.Get{{toCamelCase .OriginalName}}().AsTime()
		result.{{.Name}} = &t
	}
{{- else }}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
		result.{{.Name}} = src.Get{{toCamelCase .OriginalName}}().AsTime()
	}
{{- end }}
{{- else if eq .Type "util.UnparsedJSON" }}
{{- if .IsOptional }}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
		if data, err := protojson.Marshal(src.Get{{toCamelCase .OriginalName}}()); err == nil {
			json := util.UnparsedJSON(data)
			result.{{.Name}} = &json
		}
	}
{{- else }}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
		if data, err := protojson.Marshal(src.Get{{toCamelCase .OriginalName}}()); err == nil {
			result.{{.Name}} = util.UnparsedJSON(data)
		}
	} else {
		result.{{.Name}} = util.UnparsedJSON("{}")
	}
{{- end }}
{{- else if .IsRepeated }}
{{- if eq .Type "uuid.UUID" }}
	for _, item := range src.Get{{toCamelCase .OriginalName}}() {
		if uid, err := uuid.Parse(item); err == nil {
			result.{{.Name}} = append(result.{{.Name}}, uid)
		}
	}
{{- else if eq .Type "time.Time" }}
	for _, item := range src.Get{{toCamelCase .OriginalName}}() {
		if item != nil {
			result.{{.Name}} = append(result.{{.Name}}, item.AsTime())
		}
	}
{{- else if isMessage .Type $.Messages }}
	for _, item := range src.Get{{toCamelCase .OriginalName}}() {
		if item != nil {
			result.{{.Name}} = append(result.{{.Name}}, From{{.Type}}(item))
		}
	}
{{- else if isEnum .Type $.Enums }}
	for _, item := range src.Get{{toCamelCase .OriginalName}}() {
		result.{{.Name}} = append(result.{{.Name}}, {{.Type}}(item))
	}
{{- else }}
	result.{{.Name}} = src.Get{{toCamelCase .OriginalName}}()
{{- end }}
{{- else if isMessage .Type $.Messages }}
	if src.Get{{toCamelCase .OriginalName}}() != nil {
{{- if .IsOptional }}
		data := From{{.Type}}(src.Get{{toCamelCase .OriginalName}}())
		result.{{.Name}} = &data
{{- else }}
		result.{{.Name}} = From{{.Type}}(src.Get{{toCamelCase .OriginalName}}())
{{- end }}
	}
{{- else if isEnum .Type $.Enums }}
	// Convert enum field
	result.{{.Name}} = {{.Type}}(src.Get{{toCamelCase .OriginalName}}())
{{- else }}
{{- if .IsOptional }}
	if src.Get{{toCamelCase .OriginalName}}() != {{zeroValue .Type}} {
		val := src.Get{{toCamelCase .OriginalName}}()
		result.{{.Name}} = &val
	}
{{- else }}
	result.{{.Name}} = src.Get{{toCamelCase .OriginalName}}()
{{- end }}
{{- end }}
{{- end }}
	return result
}

// To{{.OriginalName}} converts {{.DataName}} to {{.OriginalName}}
func ({{.ReceiverVar}} {{.DataName}}) To{{.OriginalName}}() *pbTypes.{{.OriginalName}} {
	result := &pbTypes.{{.OriginalName}}{}
{{ $receiverVar := .ReceiverVar }}
{{- $mapDataNotDefined := true }}
{{- range .Fields }}
{{- if .IsMap }}
	// Convert map field {{.OriginalName}}
	if {{$receiverVar}}.{{.Name}} != nil {
{{- if eq .MapValueType "uuid.UUID" }}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]string)
		for k, v := range {{$receiverVar}}.{{.Name}} {
			result.{{toCamelCase .OriginalName}}[k] = v.String()
		}
{{- else if eq .MapValueType "time.Time" }}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]*timestamppb.Timestamp)
		for k, v := range {{$receiverVar}}.{{.Name}} {
			result.{{toCamelCase .OriginalName}}[k] = timestamppb.New(v)
		}
{{- else if eq .MapValueType "util.UnparsedJSON"}}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]*structpb.Struct)
		for k, v := range {{$receiverVar}}.{{.Name}} {
			var mapData map[string]any
			if err := json.Unmarshal([]byte(v), &mapData); err == nil {
				if structData, err := structpb.NewStruct(mapData); err == nil {
					result.{{toCamelCase .OriginalName}}[k] = structData
				}
			}
		}
{{- else if isMessage .MapValueType $.Messages }}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]*pbTypes.{{.MapValueType}})
		for k, v := range {{$receiverVar}}.{{.Name}} {
			result.{{toCamelCase .OriginalName}}[k] = v.To{{.MapValueType}}()
		}
{{- else if isEnum .MapValueType $.Enums }}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]pbTypes.{{.MapValueType}})
		for k, v := range {{$receiverVar}}.{{.Name}} {
			result.{{toCamelCase .OriginalName}}[k] = pbTypes.{{.MapValueType}}(v)
		}
{{- else }}
		result.{{toCamelCase .OriginalName}} = make(map[{{.MapKeyType}}]{{.MapValueType}})
		for k, v := range {{$receiverVar}}.{{.Name}} {
			result.{{toCamelCase .OriginalName}}[k] = v
		}
{{- end }}
	}
{{- else if eq .Type "uuid.UUID" }}
	result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}.String()
{{- else if eq .Type "time.Time" }}
{{- if .IsOptional }}
	if {{$receiverVar}}.{{.Name}} != nil {
		result.{{toCamelCase .OriginalName}} = timestamppb.New(*{{$receiverVar}}.{{.Name}})
	}
{{- else }}
	result.{{toCamelCase .OriginalName}} = timestamppb.New({{$receiverVar}}.{{.Name}})
{{- end }}{{else if eq .Type "util.UnparsedJSON" }}
{{- if .IsOptional }}
	if {{$receiverVar}}.{{.Name}} != nil {
		{{- if $mapDataNotDefined }}
		var mapData map[string]any
		{{- $mapDataNotDefined = false }}
		{{- end }}
		if err := json.Unmarshal([]byte(*{{$receiverVar}}.{{.Name}}), &mapData); err == nil {
			if structData, err := structpb.NewStruct(mapData); err == nil {
				result.{{toCamelCase .OriginalName}} = structData
			}
		}
	}
{{- else }}
	{{- if $mapDataNotDefined }}
	var mapData map[string]any
	{{- $mapDataNotDefined = false }}
	{{- end }}
	if err := json.Unmarshal([]byte({{$receiverVar}}.{{.Name}}), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.{{toCamelCase .OriginalName}} = structData
		}
	}
{{- end }}
{{- else if .IsRepeated}}{{if eq .Type "uuid.UUID" }}
	for _, item := range {{$receiverVar}}.{{.Name}} {
		result.{{toCamelCase .OriginalName}} = append(result.{{toCamelCase .OriginalName}}, item.String())
	}
{{- else if eq .Type "time.Time" }}
	for _, item := range {{$receiverVar}}.{{.Name}} {
		result.{{toCamelCase .OriginalName}} = append(result.{{toCamelCase .OriginalName}}, timestamppb.New(item))
	}
{{- else if isMessage .Type $.Messages }}
	for _, item := range {{$receiverVar}}.{{.Name}} {
		result.{{toCamelCase .OriginalName}} = append(result.{{toCamelCase .OriginalName}}, item.To{{.Type}}())
	}
{{- else if isEnum .Type $.Enums }}
	for _, item := range {{$receiverVar}}.{{.Name}} {
		result.{{toCamelCase .OriginalName}} = append(result.{{toCamelCase .OriginalName}}, pbTypes.{{.Type}}(item))
	}
{{- else }}
	result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}
{{- end }}{{else if isMessage .Type $.Messages }}
{{- if .IsOptional }}
	if {{$receiverVar}}.{{.Name}} != nil {
		result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}.To{{.Type}}()
	}
{{- else }}
	result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}.To{{.Type}}()
{{- end }}
{{- else if isEnum .Type $.Enums }}
	// Convert enum field back to pbTypes
	result.{{toCamelCase .OriginalName}} = pbTypes.{{.Type}}({{$receiverVar}}.{{.Name}})
{{- else }}
{{- if .IsOptional }}
	if {{$receiverVar}}.{{.Name}} != nil {
		result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}
	}
{{- else }}
	result.{{toCamelCase .OriginalName}} = {{$receiverVar}}.{{.Name}}
{{- end }}
{{- end }}
{{- end }}
	return result
}

{{- end }}`

// toCamelCase converts snake_case to CamelCase
func toCamelCase(s string) string {
	if s == "" {
		return ""
	}

	parts := strings.Split(s, "_")
	result := ""
	for _, part := range parts {
		if len(part) > 0 {
			result += strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return result
}

// generateReceiverVar generates a receiver variable name from message name
func generateReceiverVar(messageName string) string {
	if len(messageName) > 0 {
		return strings.ToLower(messageName[:1])
	}
	return "x"
}

// isRequestOrResponse checks if a message is a Request or Response message
func isRequestOrResponse(messageName string) bool {
	return strings.HasSuffix(messageName, "Request") || strings.HasSuffix(messageName, "Response")
}

// getDataType determines the data type for a protobuf field
func getDataType(field *protogen.Field) (dataType string, isMap bool, keyType, valueType string) {
	fieldName := string(field.Desc.Name())

	// Check if this is a map field
	if field.Desc.IsMap() {
		keyField := field.Desc.MapKey()
		valueField := field.Desc.MapValue()

		// Get key type (usually string for protobuf maps)
		keyType = getGoTypeForKind(keyField.Kind().String())

		// Get value type
		if strings.HasSuffix(string(valueField.Name()), "uid") && valueField.Kind().String() == "string" {
			valueType = "uuid.UUID"
		} else if valueField.Kind().String() == "enum" {
			// Handle enum types in maps
			valueType = string(valueField.Enum().Name())
		} else if valueField.Kind().String() == "message" && valueField.Message() != nil {
			fullName := string(valueField.Message().FullName())
			switch fullName {
			case "google.protobuf.Timestamp":
				valueType = "time.Time"
			case "google.protobuf.Struct":
				valueType = "util.UnparsedJSON"
			default:
				// For other message types, use the original name
				messageName := string(valueField.Message().Name())
				valueType = messageName
			}
		} else {
			valueType = getGoTypeForKind(valueField.Kind().String())
		}

		return fmt.Sprintf("map[%s]%s", keyType, valueType), true, keyType, valueType
	}

	// Handle UID fields
	if strings.HasSuffix(fieldName, "uid") && field.Desc.Kind().String() == "string" {
		return "uuid.UUID", false, "", ""
	}

	// Handle enum fields
	if field.Desc.Kind().String() == "enum" {
		if field.Enum != nil {
			return field.Enum.GoIdent.GoName, false, "", ""
		}
		return "int32", false, "", ""
	}

	// Handle google.protobuf.Timestamp
	if field.Desc.Kind().String() == "message" && field.Desc.Message() != nil {
		fullName := string(field.Desc.Message().FullName())
		if fullName == "google.protobuf.Timestamp" {
			return "time.Time", false, "", ""
		}

		// Handle google.protobuf.Struct
		if fullName == "google.protobuf.Struct" {
			return "util.UnparsedJSON", false, "", ""
		}

		// For other message types, use the original name
		messageName := field.Message.GoIdent.GoName
		return messageName, false, "", ""
	}

	// For other types, use the standard Go type
	return getGoType(field), false, "", ""
}

// getGoType returns the appropriate Go type for a field
func getGoType(field *protogen.Field) string {
	switch field.Desc.Kind().String() {
	case "bool":
		return "bool"
	case "int32", "sint32", "sfixed32":
		return "int32"
	case "int64", "sint64", "sfixed64":
		return "int64"
	case "uint32", "fixed32":
		return "uint32"
	case "uint64", "fixed64":
		return "uint64"
	case "float":
		return "float32"
	case "double":
		return "float64"
	case "string":
		return "string"
	case "bytes":
		return "[]byte"
	case "enum":
		// For enum types, use the local Go type name
		if field.Enum != nil {
			return field.Enum.GoIdent.GoName
		}
		return "int32"
	case "message":
		if field.Desc.Message() != nil {
			fullName := string(field.Desc.Message().FullName())
			switch fullName {
			case "google.protobuf.Timestamp":
				return "time.Time"
			case "google.protobuf.Struct":
				return "util.UnparsedJSON"
			default:
				return field.Message.GoIdent.GoName
			}
		}
		return "any"
	default:
		return "any"
	}
}

// zeroValue returns the zero value for a given type
func zeroValue(goType string) string {
	switch goType {
	case "bool":
		return "false"
	case "int32", "int64", "uint32", "uint64", "float32", "float64":
		return "0"
	case "string":
		return `""`
	case "uuid.UUID":
		return "uuid.Nil"
	default:
		// For custom types like enums, assume they have a zero value of 0
		// This is a safe assumption for protobuf enums
		return "0"
	}
}

// getGoTypeForKind returns the Go type for a protobuf kind string
func getGoTypeForKind(kind string) string {
	switch kind {
	case "bool":
		return "bool"
	case "int32", "sint32", "sfixed32":
		return "int32"
	case "int64", "sint64", "sfixed64":
		return "int64"
	case "uint32", "fixed32":
		return "uint32"
	case "uint64", "fixed64":
		return "uint64"
	case "float":
		return "float32"
	case "double":
		return "float64"
	case "string":
		return "string"
	case "bytes":
		return "[]byte"
	case "enum":
		// For enum types, we'll need more context to determine the exact type
		// This is a fallback - specific enum handling should be done elsewhere
		return "int32"
	default:
		return "any"
	}
}

// generateTypeAliasName generates a type alias name from message name
func generateTypeAliasName(messageName string) string {
	return messageName + "UID"
}

// resolveReturnType determines the appropriate return type for a UID field
func resolveReturnType(fieldName, messageName string, allMessages map[string]bool) string {
	if fieldName == "uid" {
		// For "uid" field, return the message's own UID type
		return generateTypeAliasName(messageName)
	}

	// For other uid fields like "application_uid", "node_uid", etc.
	// Try to find the corresponding message type
	prefix := fieldName[:len(fieldName)-3]   // Remove "uid"
	prefix = strings.TrimSuffix(prefix, "_") // Remove trailing underscore if any
	targetMessageName := toCamelCase(prefix)

	return generateTypeAliasName(targetMessageName)
}

// processProtoFile processes a proto file and generates data structs
func processProtoFile(plugin *protogen.Plugin, file *protogen.File) {
	var messages []DataMessage
	var hasUUIDs, hasTime, hasJSON bool
	var allMessages = make(map[string]bool)
	var enumsUsed = make(map[string]*protogen.Enum) // Track used enums
	var typeAliases = make(map[string]bool)         // Aliases for fields

	// First pass: collect all message names from all files for cross-reference resolution
	for _, f := range plugin.Files {
		for _, message := range f.Messages {
			allMessages[message.GoIdent.GoName] = true
		}
	}

	// Process each message in the file
	for _, message := range file.Messages {
		// Skip Request/Response messages
		if isRequestOrResponse(message.GoIdent.GoName) {
			continue
		}

		var fields []DataField

		// Process each field in the message
		for _, field := range message.Fields {
			fieldName := string(field.Desc.Name())
			dataType, isMap, keyType, valueType := getDataType(field)

			isRepeated := field.Desc.Cardinality().String() == "repeated" && !field.Desc.IsMap()
			isOptional := field.Desc.HasOptionalKeyword()

			// Track enum types
			if field.Desc.Kind().String() == "enum" && field.Enum != nil {
				enumsUsed[field.Enum.GoIdent.GoName] = field.Enum
			}

			// Track enum types in map values
			if isMap && strings.Contains(valueType, ".") == false {
				// Check if this could be an enum
				if field.Desc.IsMap() {
					valueField := field.Desc.MapValue()
					if valueField.Kind().String() == "enum" && valueField.Enum() != nil {
						enumName := string(valueField.Enum().Name())
						// We need to get the enum from the file's enums
						for _, fileEnum := range file.Enums {
							if fileEnum.GoIdent.GoName == enumName {
								enumsUsed[enumName] = fileEnum
								break
							}
						}
					}
				}
			}

			// Track special types
			if strings.Contains(dataType, "uuid.UUID") {
				hasUUIDs = true
			}
			if strings.Contains(dataType, "time.Time") {
				hasTime = true
			}
			if strings.Contains(dataType, "util.UnparsedJSON") {
				hasJSON = true
			}

			// Track map value types
			if isMap {
				if strings.Contains(valueType, "uuid.UUID") {
					hasUUIDs = true
				}
				if strings.Contains(valueType, "time.Time") {
					hasTime = true
				}
				if strings.Contains(valueType, "util.UnparsedJSON") {
					hasJSON = true
				}
			}

			// Fill aliases
			if fieldName == "uid" {
				returnType := resolveReturnType(fieldName, message.GoIdent.GoName, allMessages)
				typeAliases[returnType] = true
			}

			fields = append(fields, DataField{
				Name:         toCamelCase(fieldName),
				Type:         dataType,
				OriginalName: fieldName,
				IsRepeated:   isRepeated,
				IsOptional:   isOptional,
				IsMap:        isMap,
				MapKeyType:   keyType,
				MapValueType: valueType,
			})
		}

		if len(fields) == 0 {
			continue
		}

		// Sort fields for consistent output
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].Name < fields[j].Name
		})

		messages = append(messages, DataMessage{
			DataName:     message.GoIdent.GoName,
			OriginalName: message.GoIdent.GoName,
			ReceiverVar:  generateReceiverVar(message.GoIdent.GoName),
			Fields:       fields,
		})
	}

	if len(messages) == 0 {
		return
	}

	// Sort messages for consistent output
	sort.Slice(messages, func(i, j int) bool {
		return messages[i].DataName < messages[j].DataName
	})

	// Generate enum data from used enums
	var enums []EnumData
	for _, enum := range enumsUsed {
		values := make(map[string]int32)
		for _, value := range enum.Values {
			values[value.GoIdent.GoName] = int32(value.Desc.Number())
		}
		enums = append(enums, EnumData{
			Name:         enum.GoIdent.GoName,
			OriginalName: enum.GoIdent.GoName,
			Values:       values,
		})
	}

	// Sort enums for consistent output
	sort.Slice(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})

	// Convert type aliases map to sorted slice
	var typeAliasesList []TypeAlias
	for aliasName := range typeAliases {
		typeAliasesList = append(typeAliasesList, TypeAlias{Name: aliasName})
	}
	sort.Slice(typeAliasesList, func(i, j int) bool {
		return typeAliasesList[i].Name < typeAliasesList[j].Name
	})

	// Prepare template data
	fileData := FileData{
		PackageName: string(file.GoPackageName),
		Messages:    messages,
		Enums:       enums,
		TypeAliases: typeAliasesList,
		HasUUIDs:    hasUUIDs,
		HasTime:     hasTime,
		HasJSON:     hasJSON,
	}

	// Create template with custom functions
	tmpl := template.Must(template.New("data_template").Funcs(template.FuncMap{
		"toCamelCase": toCamelCase,
		"zeroValue":   zeroValue,
		"hasSuffix":   strings.HasSuffix,
		"trimSuffix":  strings.TrimSuffix,
		"isEnum": func(typeName string, enums []EnumData) bool {
			for _, enum := range enums {
				if enum.Name == typeName {
					return true
				}
			}
			return false
		},
		"isMessage": func(typeName string, messages []DataMessage) bool {
			for _, msg := range messages {
				if msg.DataName == typeName {
					return true
				}
			}
			// Also check for common message types that might be from other files
			// Message types typically start with capital letters and don't contain "."
			if len(typeName) > 0 && typeName[0] >= 'A' && typeName[0] <= 'Z' && !strings.Contains(typeName, ".") &&
				typeName != "UUID" && typeName != "Time" && !strings.HasSuffix(typeName, "_Status") {
				return true
			}
			return false
		},
	}).Parse(basicTemplate))

	// Generate the file using template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, fileData); err != nil {
		plugin.Error(fmt.Errorf("Template execution failed: %w", err))
		return
	}

	// Generate the file using protogen's file generation system
	filename := file.GeneratedFilenamePrefix + ".data.gen.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// Write the generated content
	g.P(buf.String())
}

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Fprintln(os.Stdout, build.Version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}

	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
		plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023

		// Process each proto file
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			processProtoFile(plugin, f)
		}

		return nil
	})
}
