{{define "component-start" -}}
export const {{.Name}}Form: React.FC<{{.Name -}}FormProps> = ({
  initialData,
  onSubmit,
  onCancel,
  mode,
  title,
  readonly,
  nested = false,
  onRegister,
  onFormChange
}) => {
  const [formData, setFormData] = useState<{{.Name}}FormState>(default{{.Name}}State);
  const [yamlText, setYamlText] = useState('');
  const [showYamlInput, setShowYamlInput] = useState(false);
  const [yamlError, setYamlError] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
  const [autofillMode, setAutofillMode] = useState<Record<string, 'dropdown' | 'text'>>({});
  const [structFieldText, setStructFieldText] = useState<Record<string, string>>({});
  const [structFieldErrors, setStructFieldErrors] = useState<Record<string, string>>({});
  const [hasChanges, setHasChanges] = useState(false);
  const { data } = useStreaming();

  // Store references to nested component getData and validate functions
  const nestedGetDataFns = useRef<Record<string, () => any>>({});
  const nestedValidateFns = useRef<Record<string, () => boolean>>({});
  const initialFormDataRef = useRef<{{.Name}}FormState>(default{{.Name}}State);

  // Initialize form data from initialData
  useEffect(() => {
    if (initialData) {
      const newFormData: {{.Name}}FormState = {
{{- range .Fields }}
{{- if .IsTimestamp }}
        {{.JSONName}}: initialData.{{.JSONName}} ? new Date(Number(initialData.{{.JSONName}}.seconds) * 1000).toISOString().slice(0, 16) : '',
{{- else if .IsRepeated }}
        {{.JSONName}}: initialData.{{.JSONName}} || [],
{{- else if .IsStruct }}
        {{.JSONName}}: initialData.{{.JSONName}} || {},
{{- else if .IsMessage }}
        {{.JSONName}}: initialData.{{.JSONName}} && typeof initialData.{{.JSONName}} === 'object' ? initialData.{{.JSONName}} : {{.DefaultValue}},
{{- else if .IsOptional }}
        {{.JSONName}}: initialData.{{.JSONName}} ?? {{.DefaultValue}},
{{- else }}
        {{.JSONName}}: initialData.{{.JSONName}} !== undefined && initialData.{{.JSONName}} !== null ? initialData.{{.JSONName}} : {{.DefaultValue}},
{{- end }}
{{- end }}
      };
      setFormData(newFormData);
      initialFormDataRef.current = newFormData;

      // Initialize struct field text
      const newStructText: Record<string, string> = {};
{{- range .Fields }}
{{- if .IsStruct }}
      newStructText['{{.JSONName}}'] = initialData.{{.JSONName}} ? yaml.dump(initialData.{{.JSONName}}) : '';
{{- end }}
{{- end }}
      setStructFieldText(newStructText);
    }
  }, [initialData]);

  // Track form changes
  useEffect(() => {
    if (mode === 'view' || readonly) {
      setHasChanges(false);
      return;
    }

    // Compare current form data with initial data
    const dataChanged = JSON.stringify(formData) !== JSON.stringify(initialFormDataRef.current);
    setHasChanges(dataChanged);

    // Notify parent if callback provided
    if (onFormChange) {
      onFormChange(dataChanged);
    }
  }, [formData, mode, readonly, onFormChange]);

  // Register getData and validate functions with parent if nested
  useEffect(() => {
    if (nested && onRegister) {
      onRegister(getData, validateForm);
    }
  }, [nested, onRegister, formData]);

  // Function to collect data from this component and all nested components
  const getData = () => {
    const currentFormData = { ...formData };

    // Collect data from nested components
    Object.keys(nestedGetDataFns.current).forEach(key => {
      const nestedGetData = nestedGetDataFns.current[key];
      if (nestedGetData) {
        const nestedData = nestedGetData();

        // Handle array items: key format is "fieldName[index]"
        const arrayMatch = key.match(/^(.+?)\[(\d+)\]$/);
        if (arrayMatch) {
          const fieldName = arrayMatch[1];
          const index = parseInt(arrayMatch[2], 10);
          if (!Array.isArray(currentFormData[fieldName as keyof {{.Name}}FormState])) {
            currentFormData[fieldName as keyof {{.Name}}FormState] = [] as any;
          }
          (currentFormData[fieldName as keyof {{.Name}}FormState] as any[])[index] = nestedData;
        } else if (key.includes('.')) {
          // Handle map items: key format is "fieldName.mapKey"
          const dotIndex = key.indexOf('.');
          const fieldName = key.substring(0, dotIndex);
          const mapKey = key.substring(dotIndex + 1);
          if (!currentFormData[fieldName as keyof {{.Name}}FormState] || typeof currentFormData[fieldName as keyof {{.Name}}FormState] !== 'object') {
            currentFormData[fieldName as keyof {{.Name}}FormState] = {} as any;
          }
          (currentFormData[fieldName as keyof {{.Name}}FormState] as any)[mapKey] = nestedData;
        } else {
          // Regular nested field
          currentFormData[key as keyof {{.Name}}FormState] = nestedData;
        }
      }
    });

    return currentFormData;
  };

  // Register a nested component's getData and validate functions
  const registerNestedGetData = (fieldName: string, getDataFn: () => any, validateFn?: () => boolean) => {
    nestedGetDataFns.current[fieldName] = getDataFn;
    if (validateFn) {
      nestedValidateFns.current[fieldName] = validateFn;
    }
  };

  // Unregister a nested component's getData and validate functions
  const unregisterNestedGetData = (fieldName: string) => {
    delete nestedGetDataFns.current[fieldName];
    delete nestedValidateFns.current[fieldName];
  };
{{end}}
