/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-web-ui-components. DO NOT EDIT.

import React, { useState, useEffect } from 'react';
import { create } from '@bufbuild/protobuf';
import { ResourcesSchema, type Resources } from '../../gen/aquarium/v2/label_pb';
import * as yaml from 'js-yaml';
import * as Components from './index';
import { useStreaming } from '../../app/contexts/StreamingContext';

interface ResourcesFormProps {
  mode: 'create' | 'edit' | 'view';
  initialData?: Resources;
  onSubmit: (data: Resources) => void;
  onCancel: () => void;
  title?: string;
  readonly?: boolean;
  nested?: boolean;
}

interface ResourcesFormState {
  slots: number;
  cpu: number;
  ram: number;
  disks: any;
  network: string;
  nodeFilter: string;
  multitenancy: boolean;
  cpuOverbook: boolean;
  ramOverbook: boolean;
  lifetime: string;
}
const defaultResourcesState: ResourcesFormState = {
  slots: undefined,
  cpu: 0,
  ram: 0,
  disks: {},
  network: '',
  nodeFilter: [],
  multitenancy: false,
  cpuOverbook: false,
  ramOverbook: false,
  lifetime: '',
};


export const ResourcesForm: React.FC<ResourcesFormProps> = ({
  initialData,
  onSubmit,
  onCancel,
  mode,
  title,
  readonly,
  nested = false
}) => {
  const [formData, setFormData] = useState<ResourcesFormState>(defaultResourcesState);
  const [yamlText, setYamlText] = useState('');
  const [showYamlInput, setShowYamlInput] = useState(false);
  const [yamlError, setYamlError] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
  const [autofillMode, setAutofillMode] = useState<Record<string, 'dropdown' | 'text'>>({});
  const [structFieldText, setStructFieldText] = useState<Record<string, string>>({});
  const [structFieldErrors, setStructFieldErrors] = useState<Record<string, string>>({});
  const { data } = useStreaming();

  // Initialize form data from initialData
  useEffect(() => {
    if (initialData) {
      const newFormData: ResourcesFormState = {
        slots: initialData.slots ?? undefined,
        cpu: initialData.cpu || 0,
        ram: initialData.ram || 0,
        disks: initialData.disks && typeof initialData.disks === 'object' ? initialData.disks : {},
        network: initialData.network || '',
        nodeFilter: initialData.nodeFilter || [],
        multitenancy: initialData.multitenancy || false,
        cpuOverbook: initialData.cpuOverbook || false,
        ramOverbook: initialData.ramOverbook || false,
        lifetime: initialData.lifetime || '',
      };
      setFormData(newFormData);

      // Initialize struct field text
      const newStructText: Record<string, string> = {};
      setStructFieldText(newStructText);
    }
  }, [initialData]);

  // Auto-save form data when nested and form data changes
  useEffect(() => {
    if (nested && onSubmit && formData !== defaultResourcesState) {
      // Debounce the auto-save to avoid too many calls
      const timeoutId = setTimeout(() => {
        try {
          // Convert form data to protobuf message
          const data = create(ResourcesSchema, {
            slots: formData.slots || undefined,
            cpu: formData.cpu,
            ram: formData.ram,
            disks: formData.disks,
            network: formData.network,
            nodeFilter: formData.nodeFilter,
            multitenancy: formData.multitenancy,
            cpuOverbook: formData.cpuOverbook,
            ramOverbook: formData.ramOverbook,
            lifetime: formData.lifetime,
          });
          onSubmit(data);
        } catch (error) {
          // Silently ignore errors during auto-save
        }
      }, 500); // 500ms debounce

      return () => clearTimeout(timeoutId);
    }
  }, [formData, nested, onSubmit]);


  // Load from YAML
const handleYamlLoad = () => {
  try {
    setYamlError(null);
    const parsedData = yaml.load(yamlText) as any;

    if (!parsedData || typeof parsedData !== 'object') {
      throw new Error('Invalid YAML format');
    }

    const newFormData: ResourcesFormState = { ...defaultResourcesState };
    if (parsedData.slots !== undefined) {
      newFormData.slots = parsedData.slots;
    }
    if (parsedData.cpu !== undefined) {
      newFormData.cpu = parsedData.cpu;
    }
    if (parsedData.ram !== undefined) {
      newFormData.ram = parsedData.ram;
    }
    if (parsedData.disks !== undefined) {
      newFormData.disks = parsedData.disks;
    }
    if (parsedData.network !== undefined) {
      newFormData.network = parsedData.network;
    }
    if (parsedData.nodeFilter !== undefined) {
      if (Array.isArray(parsedData.nodeFilter)) {
        newFormData.nodeFilter = parsedData.nodeFilter;
      }
    }
    if (parsedData.multitenancy !== undefined) {
      newFormData.multitenancy = parsedData.multitenancy;
    }
    if (parsedData.cpuOverbook !== undefined) {
      newFormData.cpuOverbook = parsedData.cpuOverbook;
    }
    if (parsedData.ramOverbook !== undefined) {
      newFormData.ramOverbook = parsedData.ramOverbook;
    }
    if (parsedData.lifetime !== undefined) {
      newFormData.lifetime = parsedData.lifetime;
    }

    setFormData(newFormData);
    setShowYamlInput(false);
  } catch (error) {
    setYamlError('YAML parsing error: ' + error);
  }
};

// Validate form data
const validateForm = (): boolean => {
  const errors: Record<string, string> = {};
  if (!formData.cpu) {
    errors.cpu = 'Cpu is required';
  }
  if (!formData.ram) {
    errors.ram = 'Ram is required';
  }
  if (!formData.disks) {
    errors.disks = 'Disks is required';
  }
  if (!formData.network) {
    errors.network = 'Network is required';
  }
  if (!formData.nodeFilter || formData.nodeFilter.length === 0) {
    errors.nodeFilter = 'Node Filter is required';
  }
  if (!formData.multitenancy) {
    errors.multitenancy = 'Multitenancy is required';
  }
  if (!formData.cpuOverbook) {
    errors.cpuOverbook = 'Cpu Overbook is required';
  }
  if (!formData.ramOverbook) {
    errors.ramOverbook = 'Ram Overbook is required';
  }
  if (!formData.lifetime) {
    errors.lifetime = 'Lifetime is required';
  }

  setValidationErrors(errors);
  return Object.keys(errors).length === 0;
};

// Handle form submission
const handleSubmit = () => {
  if (!validateForm()) {
    return;
  }

  try {
    // Convert form data to protobuf message
    const data = create(ResourcesSchema, {
      slots: formData.slots || undefined,
      cpu: formData.cpu,
      ram: formData.ram,
      disks: formData.disks,
      network: formData.network,
      nodeFilter: formData.nodeFilter,
      multitenancy: formData.multitenancy,
      cpuOverbook: formData.cpuOverbook,
      ramOverbook: formData.ramOverbook,
      lifetime: formData.lifetime,
    });

    onSubmit(data);
  } catch (error) {
    setYamlError('Failed to create Resources: ' + error);
  }
};

// Handle field changes
const handleFieldChange = (field: string, value: any) => {
  setFormData(prev => ({
    ...prev,
    [field]: value
  }));

  // Clear validation error for this field
  if (validationErrors[field]) {
    setValidationErrors(prev => ({
      ...prev,
      [field]: ''
    }));
  }
};

// Handle array field changes
const handleArrayChange = (field: string, index: number, value: any) => {
  setFormData(prev => ({
    ...prev,
    [field]: prev[field as keyof ResourcesFormState].map((item: any, i: number) =>
      i === index ? value : item
    )
  }));
};

// Add array item
const addArrayItem = (field: string, defaultValue: any) => {
  setFormData(prev => ({
    ...prev,
    [field]: [...(prev[field as keyof ResourcesFormState] as any[]), defaultValue]
  }));
};

// Remove array item
const removeArrayItem = (field: string, index: number) => {
  setFormData(prev => ({
    ...prev,
    [field]: (prev[field as keyof ResourcesFormState] as any[]).filter((_, i) => i !== index)
  }));
};

const isReadOnly = readonly || mode === 'view';
const formTitle = title || (mode === 'create' ? 'Create Resources' : mode === 'edit' ? 'Edit Resources' : 'View Resources');

// Helper function to get autofill options
const getAutofillOptions = (type: string) => {
  switch (type.toLowerCase()) {
    case 'label':
      return data.labels || [];
    case 'user':
      return data.users || [];
    case 'role':
      return data.roles || [];
    case 'node':
      return data.nodes || [];
    default:
      return [];
  }
};

// Helper function to parse struct field
const parseStructField = (fieldName: string, text: string) => {
  try {
    const parsed = yaml.load(text);
    if (parsed && typeof parsed === 'object') {
      handleFieldChange(fieldName, parsed);
      setStructFieldErrors(prev => ({ ...prev, [fieldName]: '' }));
    } else {
      setStructFieldErrors(prev => ({ ...prev, [fieldName]: 'Invalid YAML/JSON format' }));
    }
  } catch (error) {
    setStructFieldErrors(prev => ({ ...prev, [fieldName]: 'Parse error: ' + error }));
  }
};

// Helper function to determine if field is simple (can be inline)
const isSimpleField = (field: any) => {
  return !field.IsRepeated && !field.IsMap && !field.IsMessage && !field.IsStruct && !field.IsTimestamp && !field.AutofillType;
};


  return (
    <div className="space-y-4">
      {!nested && (
        <div className="flex justify-between items-center">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
            {formTitle}
          </h2>
          <div className="flex space-x-2">
            {!isReadOnly && (
              <button
                onClick={() => setShowYamlInput(!showYamlInput)}
                className="px-3 py-1 text-sm bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
              >
                {showYamlInput ? 'Hide YAML' : 'Load from YAML'}
              </button>
            )}
          </div>
        </div>
      )}

      {!nested && showYamlInput && (
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              YAML Configuration
            </label>
            <textarea
              value={yamlText}
              onChange={(e) => setYamlText(e.target.value)}
              className="w-full h-32 px-3 py-2 border border-gray-300 rounded-md font-mono text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              placeholder="Enter YAML configuration here..."
            />
          </div>
          <div className="flex space-x-2">
            <button
              onClick={handleYamlLoad}
              className="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700"
            >
              Load from YAML
            </button>
            <button
              onClick={() => setShowYamlInput(false)}
              className="px-4 py-2 text-sm bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
            >
              Cancel
            </button>
          </div>
          {yamlError && (
            <div className="text-sm text-red-600 dark:text-red-400">
              {yamlError}
            </div>
          )}
        </div>
      )}

      {(!nested || !showYamlInput) && (
        <div className="space-y-3">
{/* Slots field */}
  <div>
{/* Simple number field - inline layout */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Slots
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Global amount of slots to be filled with ApplicationResources</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4">
    <input
      type="number"
      value={formData.slots}
      onChange={(e) => handleFieldChange('slots', parseInt(e.target.value) || 0)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="w-full px-3 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
    />
    {validationErrors.slots && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1">
        {validationErrors.slots}
      </div>
    )}
  </div>
</div>

  </div>{/* Cpu field */}
  <div>
{/* Simple number field - inline layout */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Cpu *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Amount of vCPUs (logical CPU with HT enabled will have 2 per core)</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4">
    <input
      type="number"
      value={formData.cpu}
      onChange={(e) => handleFieldChange('cpu', parseInt(e.target.value) || 0)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="w-full px-3 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
    />
    {validationErrors.cpu && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1">
        {validationErrors.cpu}
      </div>
    )}
  </div>
</div>

  </div>{/* Ram field */}
  <div>
{/* Simple number field - inline layout */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Ram *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Amount of RAM in GB</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4">
    <input
      type="number"
      value={formData.ram}
      onChange={(e) => handleFieldChange('ram', parseInt(e.target.value) || 0)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="w-full px-3 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
    />
    {validationErrors.ram && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1">
        {validationErrors.ram}
      </div>
    )}
  </div>
</div>

  </div>{/* Disks field */}
  <div>
    {/* Complex field - traditional layout */}
    <div className="space-y-2">
<div className="flex items-center space-x-2">
  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
    Disks *
  </label>
  <div className="relative group">
    <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
    <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
      <pre className="whitespace-pre-wrap text-xs leading-relaxed">Defines disks to attach/clone...</pre>
    </div>
  </div>
</div>

<div className="border border-gray-300 rounded-md p-3 dark:border-gray-600 space-y-4">
  <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
    Disks (string → ResourcesDisk)
  </div>
  {/* Map with message values - render nested components */}
  <div className="space-y-3">
    {Object.entries(formData.disks || {}).map(([key, value]) => (
      <div key={key} className="relative border border-gray-300 rounded-lg p-3 bg-gray-50 dark:bg-gray-700 dark:border-gray-600">
        <div className="flex items-center justify-between mb-3 pb-2 border-b border-gray-200 dark:border-gray-600">
          <input
            type="text"
            value={key}
            onChange={(e) => {
              const newMap = { ...formData.disks };
              if (e.target.value !== key) {
                delete newMap[key];
                newMap[e.target.value] = value;
                handleFieldChange('disks', newMap);
              }
            }}
            disabled={isReadOnly || (mode === 'edit' && false)}
            className="flex-1 max-w-xs px-2 py-1 text-sm border border-gray-300 rounded dark:bg-gray-600 dark:border-gray-500"
            placeholder="Key"
          />
          {!isReadOnly && !(mode === 'edit' && false) && (
            <button
              type="button"
              onClick={() => {
                const newMap = { ...formData.disks };
                delete newMap[key];
                handleFieldChange('disks', newMap);
              }}
              className="flex items-center justify-center w-6 h-6 text-red-500 hover:text-red-700 hover:bg-red-100 rounded-full transition-colors ml-2"
              title="Remove entry"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>
        <div className="pl-2">
          {(() => {
            const ComponentName = 'ResourcesDiskForm';
            const NestedComponent = (Components as any)[ComponentName];

            if (NestedComponent) {
              return (
                <NestedComponent
                  mode={mode}
                  initialData={value}
                  onSubmit={(data: any) => {
                    const newMap = { ...formData.disks };
                    newMap[key] = data;
                    handleFieldChange('disks', newMap);
                  }}
                  onCancel={() => {}}
                  title={key}
                  readonly={isReadOnly || (mode === 'edit' && false)}
                  nested={true}
                />
              );
            }

            // Fallback to JSON editor
            return (
              <div className="space-y-2">
                <div className="text-xs text-gray-500">
                  ResourcesDisk (Component not available)
                </div>
                <textarea
                  value={JSON.stringify(value, null, 2)}
                  onChange={(e) => {
                    try {
                      const parsed = JSON.parse(e.target.value);
                      const newMap = { ...formData.disks };
                      newMap[key] = parsed;
                      handleFieldChange('disks', newMap);
                    } catch (error) {
                      // Invalid JSON, keep the text value for user to fix
                    }
                  }}
                  disabled={isReadOnly || (mode === 'edit' && false)}
                  className="w-full h-20 px-2 py-1 text-sm border border-gray-300 rounded font-mono dark:bg-gray-600 dark:border-gray-500 dark:text-white"
                  placeholder="Enter JSON object..."
                />
              </div>
            );
          })()}
        </div>
      </div>
    ))}
    {!isReadOnly && !(mode === 'edit' && false) && (
      <button
        type="button"
        onClick={() => {
          const newKey = 'new_key_' + Date.now();
          const newMap = { ...formData.disks };
          newMap[newKey] = {};
          handleFieldChange('disks', newMap);
        }}
        className="w-full px-3 py-2 text-sm border-2 border-dashed border-gray-300 text-gray-600 rounded-md hover:border-green-400 hover:text-green-600 transition-colors"
      >
        + Add ResourcesDisk
      </button>
    )}
  </div>
</div>

{validationErrors.disks && (
  <div className="text-sm text-red-600 dark:text-red-400 mt-1">
    {validationErrors.disks}
  </div>
)}

    </div>
  </div>{/* Network field */}
  <div>
{/* Simple string field - inline layout */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Network *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Which network configuration to use for the environment</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4">
    <input
      type="text"
      value={formData.network}
      onChange={(e) => handleFieldChange('network', e.target.value)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="w-full px-3 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
    />
    {validationErrors.network && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1">
        {validationErrors.network}
      </div>
    )}
  </div>
</div>

  </div>{/* Node Filter field */}
  <div>
    {/* Complex field - traditional layout */}
    <div className="space-y-2">
<div className="flex items-center space-x-2">
  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
    Node Filter *
  </label>
  <div className="relative group">
    <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
    <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
      <pre className="whitespace-pre-wrap text-xs leading-relaxed">The list of the Node identifiers to run resource on, supports path wildcards example: - OS:darwin - OSVersion:12.* - Arch:x86_64</pre>
    </div>
  </div>
</div>

<div className="space-y-3">
  {formData.nodeFilter.map((item, index) => (
    <div key={index} className="relative border-2 border-gray-200 rounded-lg p-3 dark:border-gray-600 bg-gray-50 dark:bg-gray-800">
      <div className="flex items-center justify-between">
        <input
          type="text"
          value={item}
          onChange={(e) => handleArrayChange('nodeFilter', index, e.target.value)}
          disabled={isReadOnly || (mode === 'edit' && false)}
          className="flex-1 mr-3 px-3 py-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
        {!isReadOnly && !(mode === 'edit' && false) && (
          <button
            type="button"
            onClick={() => removeArrayItem('nodeFilter', index)}
            className="flex items-center justify-center w-6 h-6 text-red-500 hover:text-red-700 hover:bg-red-100 rounded-full transition-colors"
            title="Remove item"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        )}
      </div>
    </div>
  ))}
  {!isReadOnly && !(mode === 'edit' && false) && (
    <button
      onClick={() => addArrayItem('nodeFilter', '')}
      className="w-full px-3 py-2 text-sm border-2 border-dashed border-gray-300 text-gray-600 rounded-md hover:border-green-400 hover:text-green-600 transition-colors"
    >
      + Add Node Filter
    </button>
  )}
</div>

{validationErrors.nodeFilter && (
  <div className="text-sm text-red-600 dark:text-red-400 mt-1">
    {validationErrors.nodeFilter}
  </div>
)}

    </div>
  </div>{/* Multitenancy field */}
  <div>
{/* Boolean field - inline layout with checkbox */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Multitenancy *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Tolerate to run along with the other envs on the same node</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4 flex justify-start">
    <input
      type="checkbox"
      checked={formData.multitenancy}
      onChange={(e) => handleFieldChange('multitenancy', e.target.checked)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
    />
    {validationErrors.multitenancy && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1 ml-2">
        {validationErrors.multitenancy}
      </div>
    )}
  </div>
</div>

  </div>{/* Cpu Overbook field */}
  <div>
{/* Boolean field - inline layout with checkbox */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Cpu Overbook *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Tolerate to node CPU overbooking when executed together with other envs</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4 flex justify-start">
    <input
      type="checkbox"
      checked={formData.cpuOverbook}
      onChange={(e) => handleFieldChange('cpuOverbook', e.target.checked)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
    />
    {validationErrors.cpuOverbook && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1 ml-2">
        {validationErrors.cpuOverbook}
      </div>
    )}
  </div>
</div>

  </div>{/* Ram Overbook field */}
  <div>
{/* Boolean field - inline layout with checkbox */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Ram Overbook *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Tolerate to RAM overbooking when executed together with other envs</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4 flex justify-start">
    <input
      type="checkbox"
      checked={formData.ramOverbook}
      onChange={(e) => handleFieldChange('ramOverbook', e.target.checked)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
    />
    {validationErrors.ramOverbook && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1 ml-2">
        {validationErrors.ramOverbook}
      </div>
    )}
  </div>
</div>

  </div>{/* Lifetime field */}
  <div>
{/* Simple string field - inline layout */}
<div className="flex items-center justify-between">
  <div className="flex items-center space-x-2 min-w-0 flex-1">
    <label className="text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap">
      Lifetime *
    </label>
    <div className="relative group">
      <span className="cursor-help text-gray-400 hover:text-gray-600">(?)</span>
      <div className="absolute left-0 bottom-6 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none max-w-sm w-max p-3 min-w-64 max-h-48 overflow-y-auto">
        <pre className="whitespace-pre-wrap text-xs leading-relaxed">Total lifetime of the ApplicationResource in Time Duration (ex. "1h30m30s"). Begins on ApplicationResource create time till deallocate by user or auto deallocate by timeout. If it's empty or "0" then default value from fish node config will be used. If it's negative (ex. "-1s") then the ApplicationResource will live forever or until the user requests deallocate.</pre>
      </div>
    </div>
  </div>
  <div className="flex-1 max-w-xs ml-4">
    <input
      type="text"
      value={formData.lifetime}
      onChange={(e) => handleFieldChange('lifetime', e.target.value)}
      disabled={isReadOnly || (mode === 'edit' && false)}
      className="w-full px-3 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
    />
    {validationErrors.lifetime && (
      <div className="text-xs text-red-600 dark:text-red-400 mt-1">
        {validationErrors.lifetime}
      </div>
    )}
  </div>
</div>

  </div>

        </div>
      )}

      {!nested && (
        <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200 dark:border-gray-700">
          <button
            onClick={onCancel}
            className="px-4 py-2 text-sm bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
          >
            {isReadOnly ? 'Close' : 'Cancel'}
          </button>
          {!isReadOnly && (
            <button
              onClick={handleSubmit}
              className="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700"
            >
              {mode === 'create' ? 'Create' : 'Save'}
            </button>
          )}
        </div>
      )}
    </div>
  );
};
