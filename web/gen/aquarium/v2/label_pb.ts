// Copyright 2025 Adobe. All rights reserved.
// This file is licensed to you under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License. You may obtain a copy
// of the License at http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
// OF ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.

// Author: Sergei Parshev (@sparshev)

// @generated by protoc-gen-es v2.6.2 with parameter "target=ts"
// @generated from file aquarium/v2/label.proto (package aquarium.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Authentication } from "./common_pb";
import { file_aquarium_v2_common } from "./common_pb";
import { file_aquarium_v2_options_rbac } from "./options_rbac_pb";
import { file_aquarium_v2_options_streaming } from "./options_streaming_pb";
import { file_aquarium_v2_options_ui } from "./options_ui_pb";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file aquarium/v2/label.proto.
 */
export const file_aquarium_v2_label: GenFile = /*@__PURE__*/
  fileDesc("ChdhcXVhcml1bS92Mi9sYWJlbC5wcm90bxILYXF1YXJpdW0udjIitQMKBUxhYmVsEhUKA3VpZBgBIAEoCUIImrUYBAgBEAESOAoKY3JlYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCJq1GAQIARABEjgKCnVwZGF0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgiatRgECAEQARIUCgRuYW1lGAQgASgJQgaatRgCEAESFwoHdmVyc2lvbhgFIAEoBUIGmrUYAhABEhwKCm93bmVyX25hbWUYBiABKAlCCJq1GAQIARABEjEKC2RlZmluaXRpb25zGAcgAygLMhwuYXF1YXJpdW0udjIuTGFiZWxEZWZpbml0aW9uEjEKCG1ldGFkYXRhGAggASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdEIGmrUYAigAEhsKC3Zpc2libGVfZm9yGAkgAygJQgaatRgCKAASMgoJcmVtb3ZlX2F0GAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAiAEBOg+KtRgFCgNHZXSStRgCCAFCDAoKX3JlbW92ZV9hdCL/AQoPTGFiZWxEZWZpbml0aW9uEg4KBmRyaXZlchgBIAEoCRIqCgZpbWFnZXMYAiADKAsyEi5hcXVhcml1bS52Mi5JbWFnZUIGmrUYAigAEjAKB29wdGlvbnMYAyABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0QgaatRgCKAASKQoJcmVzb3VyY2VzGAQgASgLMhYuYXF1YXJpdW0udjIuUmVzb3VyY2VzEjgKDmF1dGhlbnRpY2F0aW9uGAUgASgLMhsuYXF1YXJpdW0udjIuQXV0aGVudGljYXRpb25IAIgBAToGkrUYAggBQhEKD19hdXRoZW50aWNhdGlvbiK+AwoJUmVzb3VyY2VzEhIKBXNsb3RzGAEgASgNSACIAQESCwoDY3B1GAIgASgNEgsKA3JhbRgDIAEoDRI4CgVkaXNrcxgEIAMoCzIhLmFxdWFyaXVtLnYyLlJlc291cmNlcy5EaXNrc0VudHJ5QgaatRgCKAASHAoHbmV0d29yaxgFIAEoCUIGmrUYAigASAGIAQESGwoLbm9kZV9maWx0ZXIYBiADKAlCBpq1GAIoABIZCgxtdWx0aXRlbmFuY3kYByABKAhIAogBARIZCgxjcHVfb3ZlcmJvb2sYCCABKAhIA4gBARIZCgxyYW1fb3ZlcmJvb2sYCSABKAhIBIgBARIVCghsaWZldGltZRgKIAEoCUgFiAEBGkgKCkRpc2tzRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhouYXF1YXJpdW0udjIuUmVzb3VyY2VzRGlzazoCOAE6BpK1GAIIAUIICgZfc2xvdHNCCgoIX25ldHdvcmtCDwoNX211bHRpdGVuYW5jeUIPCg1fY3B1X292ZXJib29rQg8KDV9yYW1fb3ZlcmJvb2tCCwoJX2xpZmV0aW1lIqkBCg1SZXNvdXJjZXNEaXNrEhEKBHR5cGUYASABKAlIAIgBARISCgVsYWJlbBgCIAEoCUgBiAEBEhEKBHNpemUYAyABKA1IAogBARISCgVyZXVzZRgEIAEoCEgDiAEBEhIKBWNsb25lGAUgASgJSASIAQE6BpK1GAIIAUIHCgVfdHlwZUIICgZfbGFiZWxCBwoFX3NpemVCCAoGX3JldXNlQggKBl9jbG9uZSKbAQoFSW1hZ2USEQoEbmFtZRgBIAEoCUgAiAEBEhAKA3VybBgCIAEoCUgBiAEBEhAKA3N1bRgDIAEoCUgCiAEBEhQKB3ZlcnNpb24YBCABKAlIA4gBARIQCgN0YWcYBSABKAlIBIgBAToGkrUYAggBQgcKBV9uYW1lQgYKBF91cmxCBgoEX3N1bUIKCghfdmVyc2lvbkIGCgRfdGFnIlcKF0xhYmVsU2VydmljZUxpc3RSZXF1ZXN0EhEKBG5hbWUYASABKAlIAIgBARIUCgd2ZXJzaW9uGAIgASgJSAGIAQFCBwoFX25hbWVCCgoIX3ZlcnNpb24iXQoYTGFiZWxTZXJ2aWNlTGlzdFJlc3BvbnNlEg4KBnN0YXR1cxgBIAEoCBIPCgdtZXNzYWdlGAIgASgJEiAKBGRhdGEYAyADKAsyEi5hcXVhcml1bS52Mi5MYWJlbCIrChZMYWJlbFNlcnZpY2VHZXRSZXF1ZXN0EhEKCWxhYmVsX3VpZBgBIAEoCSJcChdMYWJlbFNlcnZpY2VHZXRSZXNwb25zZRIOCgZzdGF0dXMYASABKAgSDwoHbWVzc2FnZRgCIAEoCRIgCgRkYXRhGAMgASgLMhIuYXF1YXJpdW0udjIuTGFiZWwiPgoZTGFiZWxTZXJ2aWNlQ3JlYXRlUmVxdWVzdBIhCgVsYWJlbBgBIAEoCzISLmFxdWFyaXVtLnYyLkxhYmVsIl8KGkxhYmVsU2VydmljZUNyZWF0ZVJlc3BvbnNlEg4KBnN0YXR1cxgBIAEoCBIPCgdtZXNzYWdlGAIgASgJEiAKBGRhdGEYAyABKAsyEi5hcXVhcml1bS52Mi5MYWJlbCI+ChlMYWJlbFNlcnZpY2VVcGRhdGVSZXF1ZXN0EiEKBWxhYmVsGAEgASgLMhIuYXF1YXJpdW0udjIuTGFiZWwiXwoaTGFiZWxTZXJ2aWNlVXBkYXRlUmVzcG9uc2USDgoGc3RhdHVzGAEgASgIEg8KB21lc3NhZ2UYAiABKAkSIAoEZGF0YRgDIAEoCzISLmFxdWFyaXVtLnYyLkxhYmVsIi4KGUxhYmVsU2VydmljZVJlbW92ZVJlcXVlc3QSEQoJbGFiZWxfdWlkGAEgASgJIj0KGkxhYmVsU2VydmljZVJlbW92ZVJlc3BvbnNlEg4KBnN0YXR1cxgBIAEoCBIPCgdtZXNzYWdlGAIgASgJMrQECgxMYWJlbFNlcnZpY2USaAoETGlzdBIkLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZUxpc3RSZXF1ZXN0GiUuYXF1YXJpdW0udjIuTGFiZWxTZXJ2aWNlTGlzdFJlc3BvbnNlIhOCtRgPGgRVc2VyIgdMaXN0QWxsEmQKA0dldBIjLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZUdldFJlcXVlc3QaJC5hcXVhcml1bS52Mi5MYWJlbFNlcnZpY2VHZXRSZXNwb25zZSISgrUYDhoEVXNlciIGR2V0QWxsEnAKBkNyZWF0ZRImLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZUNyZWF0ZVJlcXVlc3QaJy5hcXVhcml1bS52Mi5MYWJlbFNlcnZpY2VDcmVhdGVSZXNwb25zZSIVgrUYERoEVXNlciIJQ3JlYXRlQWxsEnAKBlVwZGF0ZRImLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZVVwZGF0ZVJlcXVlc3QaJy5hcXVhcml1bS52Mi5MYWJlbFNlcnZpY2VVcGRhdGVSZXNwb25zZSIVgrUYERoEVXNlciIJVXBkYXRlQWxsEnAKBlJlbW92ZRImLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZVJlbW92ZVJlcXVlc3QaJy5hcXVhcml1bS52Mi5MYWJlbFNlcnZpY2VSZW1vdmVSZXNwb25zZSIVgrUYERoEVXNlciIJUmVtb3ZlQWxsQkVaQ2dpdGh1Yi5jb20vYWRvYmUvYXF1YXJpdW0tZmlzaC9saWIvcnBjL3Byb3RvL2FxdWFyaXVtL3YyO2FxdWFyaXVtdjJiBnByb3RvMw", [file_google_protobuf_timestamp, file_google_protobuf_struct, file_aquarium_v2_common, file_aquarium_v2_options_rbac, file_aquarium_v2_options_streaming, file_aquarium_v2_options_ui]);

/**
 * Label represents a reproducible environment configuration
 *
 * This one filled by the cluster admin, depends on the needs. Labels could be defined in
 * different drivers and the priority is sequential. Version could be used during request and
 * by default is the latest.
 *
 * Label - is one of the most important part of the system, because it makes the resources
 * reproducible in time. Definitions contains the driver name and configuration, so can be
 * started again and again as much times we need. Versions make possible to update the labels
 * and store the old ones in case we need to run the same environment 10y from now and rebuild
 * the old code revision for example.
 *
 * Labels can't be updated. Once they are stored - they are here to keep the history of
 * environements and make possible to mark build with the specified label version in order to
 * be able to reproduce it later. Also labels can be implemented just by one or multiple
 * drivers. Sometimes it's useful to switch to another provider in case the previous ones are
 * not available or completely used.
 *
 * Combination of Name and Version should be unique.
 *
 * @generated from message aquarium.v2.Label
 */
export type Label = Message<"aquarium.v2.Label"> & {
  /**
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 3;
   */
  updatedAt?: Timestamp;

  /**
   * Simple name to identify the Label
   * example: macos1405-xcode161-ci_aws
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * In order to update the labels freely and save the previous Label state for the past builds.
   * Editable labels has version 0 and could be updated. Those labls has to have remove_at defined.
   * The regular labels starting with 1 and goes until int32 is over and you can't edit those, only add new ones.
   *
   * @generated from field: int32 version = 5;
   */
  version: number;

  /**
   * User who owns this label, if empty - then admin
   *
   * @generated from field: string owner_name = 6;
   */
  ownerName: string;

  /**
   * List of label definitions that describes required resources, driver and it's options.
   * The order is sequential - so the priority is to the first driver and if it's not
   * available than the next definitions will be used.
   * example:
   *   - driver: vmx
   *     images:
   *       - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019/winserver2019-VERSION.tar.xz'
   *       - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019-vs2019/winserver2019-vs2019-VERSION.tar.xz'
   *       - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019-vs2019-ci/winserver2019-vs2019-ci-VERSION.tar.xz'
   *     resources:
   *       cpu: 16
   *       ram: 20
   *       disks:
   *         ws:
   *           size: 100
   *           reuse: true
   *       network: nat
   *   - driver: aws
   *     images:
   *       - name: aquarium/winserver2019-vs2019-ci-VERSION
   *     options:
   *       instance_type: c6a.4xlarge
   *       security_groups:
   *         - jenkins-worker
   *       userdata_format: ps1
   *     resources:
   *       cpu: 16
   *       ram: 32
   *       disks:
   *         xvdb:
   *           size: 100
   *       network: Name:build-vpc
   *
   * @generated from field: repeated aquarium.v2.LabelDefinition definitions = 7;
   */
  definitions: LabelDefinition[];

  /**
   * Basic metadata to pass to the ApplicationResource
   * example:
   *   JENKINS_AGENT_WORKSPACE: 'D:\'
   *
   * @generated from field: google.protobuf.Struct metadata = 8;
   */
  metadata?: JsonObject;

  /**
   * List defines users or teams that can see the label, if empty then anyone can see it
   *
   * @generated from field: repeated string visible_for = 9;
   */
  visibleFor: string[];

  /**
   * When the temporary template will become unavailable to be used and will be removed.
   * If not set - then it's a persistent label (version > 0), when version == 0 then this field must be defined.
   * When time has come - the label can't be used to run new Application, but will exist until the last Application
   * which used this label is removed. Then when it's time to remove the label - it will ask driver to post-process
   * the label definitions as well (driver will decide what to do based on options provided within the definitions).
   *
   * @generated from field: optional google.protobuf.Timestamp remove_at = 10;
   */
  removeAt?: Timestamp;
};

/**
 * Describes the message aquarium.v2.Label.
 * Use `create(LabelSchema)` to create a new message.
 */
export const LabelSchema: GenMessage<Label> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 0);

/**
 * LabelDefinition describes how to provide resources
 *
 * Describes Label's ways to provide aa ApplicationResource - it contains name of the driver,
 * it's resource and additional options.
 *
 * @generated from message aquarium.v2.LabelDefinition
 */
export type LabelDefinition = Message<"aquarium.v2.LabelDefinition"> & {
  /**
   * Name of the driver to execute
   *
   * @generated from field: string driver = 1;
   */
  driver: string;

  /**
   * Image(s) to use for the environment to startup
   *
   * @generated from field: repeated aquarium.v2.Image images = 2;
   */
  images: Image[];

  /**
   * Driver-specific options to execute the environment
   *
   * @generated from field: google.protobuf.Struct options = 3;
   */
  options?: JsonObject;

  /**
   * Resources Driver need to provide for the Label execution
   *
   * @generated from field: aquarium.v2.Resources resources = 4;
   */
  resources?: Resources;

  /**
   * Authentication information to connect - is used by:
   * * ProxySSH gate to allow access to the resource
   *
   * @generated from field: optional aquarium.v2.Authentication authentication = 5;
   */
  authentication?: Authentication;
};

/**
 * Describes the message aquarium.v2.LabelDefinition.
 * Use `create(LabelDefinitionSchema)` to create a new message.
 */
export const LabelDefinitionSchema: GenMessage<LabelDefinition> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 1);

/**
 * Resources defines required compute resources for a label
 *
 * It's used for 2 purposes, in Label definitions to describe the required amount of resources
 * and in Fish to store the currently used resources, so could add and subtract resources.
 *
 * Modificators are used for parallel node usage by different Applications, they are stored
 * for the first Application and used for the others to determine node tenancy/overbook
 * tolerance.
 *
 * Different drivers uses it in different ways to provide quite similar functionality, so it's
 * a good idea to check the driver's wiki page to get some clue on how to create Label def.
 *
 * @generated from message aquarium.v2.Resources
 */
export type Resources = Message<"aquarium.v2.Resources"> & {
  /**
   * Global amount of slots to be filled with ApplicationResources
   *
   * @generated from field: optional uint32 slots = 1;
   */
  slots?: number;

  /**
   * Amount of vCPUs (logical CPU with HT enabled will have 2 per core)
   *
   * @generated from field: uint32 cpu = 2;
   */
  cpu: number;

  /**
   * Amount of RAM in GB
   *
   * @generated from field: uint32 ram = 3;
   */
  ram: number;

  /**
   * Defines disks to attach/clone...
   *
   * @generated from field: map<string, aquarium.v2.ResourcesDisk> disks = 4;
   */
  disks: { [key: string]: ResourcesDisk };

  /**
   * Which network configuration to use for the environment
   *
   * @generated from field: optional string network = 5;
   */
  network?: string;

  /**
   * The list of the Node identifiers to run resource on, supports path wildcards
   * example:
   *   - OS:darwin
   *   - OSVersion:12.*
   *   - Arch:x86_64
   *
   * @generated from field: repeated string node_filter = 6;
   */
  nodeFilter: string[];

  /**
   * Tolerate to run along with the other envs on the same node
   *
   * @generated from field: optional bool multitenancy = 7;
   */
  multitenancy?: boolean;

  /**
   * Tolerate to node CPU overbooking when executed together with other envs
   *
   * @generated from field: optional bool cpu_overbook = 8;
   */
  cpuOverbook?: boolean;

  /**
   * Tolerate to RAM overbooking when executed together with other envs
   *
   * @generated from field: optional bool ram_overbook = 9;
   */
  ramOverbook?: boolean;

  /**
   * Total lifetime of the ApplicationResource in Time Duration (ex. "1h30m30s"). Begins on
   * ApplicationResource create time till deallocate by user or auto deallocate by timeout.
   * If it's empty or "0" then default value from fish node config will be used. If it's
   * negative (ex. "-1s") then the ApplicationResource will live forever or until the user
   * requests deallocate.
   *
   * @generated from field: optional string lifetime = 10;
   */
  lifetime?: string;
};

/**
 * Describes the message aquarium.v2.Resources.
 * Use `create(ResourcesSchema)` to create a new message.
 */
export const ResourcesSchema: GenMessage<Resources> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 2);

/**
 * ResourcesDisk defines disk configuration
 *
 * @generated from message aquarium.v2.ResourcesDisk
 */
export type ResourcesDisk = Message<"aquarium.v2.ResourcesDisk"> & {
  /**
   * Type of the filesystem to create by Fish - usually handled by the formatter of the image
   *
   * @generated from field: optional string type = 1;
   */
  type?: string;

  /**
   * Volume name will be given to the disk, empty will use the disk key
   *
   * @generated from field: optional string label = 2;
   */
  label?: string;

  /**
   * Amount of disk space in GB for new disk, could not used if clone is set
   *
   * @generated from field: optional uint32 size = 3;
   */
  size?: number;

  /**
   * Do not remove the disk and reuse it for the next resource run
   *
   * @generated from field: optional bool reuse = 4;
   */
  reuse?: boolean;

  /**
   * Clone the snapshot of existing disk instead of creating the new one
   *
   * @generated from field: optional string clone = 5;
   */
  clone?: string;
};

/**
 * Describes the message aquarium.v2.ResourcesDisk.
 * Use `create(ResourcesDiskSchema)` to create a new message.
 */
export const ResourcesDiskSchema: GenMessage<ResourcesDisk> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 3);

/**
 * @generated from message aquarium.v2.Image
 */
export type Image = Message<"aquarium.v2.Image"> & {
  /**
   * Name of the image, if not set will use a part of the Url file name prior to last minus ("-") or ext
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Address of the remote image to download it
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  /**
   * Checksum of the image in format "<algo>:<checksum>"
   *
   * @generated from field: optional string sum = 3;
   */
  sum?: string;

  /**
   * Version of the image, if not set will use a part of the Url file name after the last minus ("-") to ext
   *
   * @generated from field: optional string version = 4;
   */
  version?: string;

  /**
   * Identifier used by drivers to make sure the images will be processed properly
   *
   * @generated from field: optional string tag = 5;
   */
  tag?: string;
};

/**
 * Describes the message aquarium.v2.Image.
 * Use `create(ImageSchema)` to create a new message.
 */
export const ImageSchema: GenMessage<Image> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 4);

/**
 * @generated from message aquarium.v2.LabelServiceListRequest
 */
export type LabelServiceListRequest = Message<"aquarium.v2.LabelServiceListRequest"> & {
  /**
   * Filter the list by name of the label
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Filter the list by version of the label, "last" will return only latest version of labels
   *
   * @generated from field: optional string version = 2;
   */
  version?: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceListRequest.
 * Use `create(LabelServiceListRequestSchema)` to create a new message.
 */
export const LabelServiceListRequestSchema: GenMessage<LabelServiceListRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 5);

/**
 * @generated from message aquarium.v2.LabelServiceListResponse
 */
export type LabelServiceListResponse = Message<"aquarium.v2.LabelServiceListResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: repeated aquarium.v2.Label data = 3;
   */
  data: Label[];
};

/**
 * Describes the message aquarium.v2.LabelServiceListResponse.
 * Use `create(LabelServiceListResponseSchema)` to create a new message.
 */
export const LabelServiceListResponseSchema: GenMessage<LabelServiceListResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 6);

/**
 * @generated from message aquarium.v2.LabelServiceGetRequest
 */
export type LabelServiceGetRequest = Message<"aquarium.v2.LabelServiceGetRequest"> & {
  /**
   * @generated from field: string label_uid = 1;
   */
  labelUid: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceGetRequest.
 * Use `create(LabelServiceGetRequestSchema)` to create a new message.
 */
export const LabelServiceGetRequestSchema: GenMessage<LabelServiceGetRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 7);

/**
 * @generated from message aquarium.v2.LabelServiceGetResponse
 */
export type LabelServiceGetResponse = Message<"aquarium.v2.LabelServiceGetResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: aquarium.v2.Label data = 3;
   */
  data?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceGetResponse.
 * Use `create(LabelServiceGetResponseSchema)` to create a new message.
 */
export const LabelServiceGetResponseSchema: GenMessage<LabelServiceGetResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 8);

/**
 * @generated from message aquarium.v2.LabelServiceCreateRequest
 */
export type LabelServiceCreateRequest = Message<"aquarium.v2.LabelServiceCreateRequest"> & {
  /**
   * @generated from field: aquarium.v2.Label label = 1;
   */
  label?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceCreateRequest.
 * Use `create(LabelServiceCreateRequestSchema)` to create a new message.
 */
export const LabelServiceCreateRequestSchema: GenMessage<LabelServiceCreateRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 9);

/**
 * @generated from message aquarium.v2.LabelServiceCreateResponse
 */
export type LabelServiceCreateResponse = Message<"aquarium.v2.LabelServiceCreateResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: aquarium.v2.Label data = 3;
   */
  data?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceCreateResponse.
 * Use `create(LabelServiceCreateResponseSchema)` to create a new message.
 */
export const LabelServiceCreateResponseSchema: GenMessage<LabelServiceCreateResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 10);

/**
 * @generated from message aquarium.v2.LabelServiceUpdateRequest
 */
export type LabelServiceUpdateRequest = Message<"aquarium.v2.LabelServiceUpdateRequest"> & {
  /**
   * @generated from field: aquarium.v2.Label label = 1;
   */
  label?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceUpdateRequest.
 * Use `create(LabelServiceUpdateRequestSchema)` to create a new message.
 */
export const LabelServiceUpdateRequestSchema: GenMessage<LabelServiceUpdateRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 11);

/**
 * @generated from message aquarium.v2.LabelServiceUpdateResponse
 */
export type LabelServiceUpdateResponse = Message<"aquarium.v2.LabelServiceUpdateResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: aquarium.v2.Label data = 3;
   */
  data?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceUpdateResponse.
 * Use `create(LabelServiceUpdateResponseSchema)` to create a new message.
 */
export const LabelServiceUpdateResponseSchema: GenMessage<LabelServiceUpdateResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 12);

/**
 * @generated from message aquarium.v2.LabelServiceRemoveRequest
 */
export type LabelServiceRemoveRequest = Message<"aquarium.v2.LabelServiceRemoveRequest"> & {
  /**
   * @generated from field: string label_uid = 1;
   */
  labelUid: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceRemoveRequest.
 * Use `create(LabelServiceRemoveRequestSchema)` to create a new message.
 */
export const LabelServiceRemoveRequestSchema: GenMessage<LabelServiceRemoveRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 13);

/**
 * @generated from message aquarium.v2.LabelServiceRemoveResponse
 */
export type LabelServiceRemoveResponse = Message<"aquarium.v2.LabelServiceRemoveResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceRemoveResponse.
 * Use `create(LabelServiceRemoveResponseSchema)` to create a new message.
 */
export const LabelServiceRemoveResponseSchema: GenMessage<LabelServiceRemoveResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 14);

/**
 * LabelService handles label management operations
 *
 * @generated from service aquarium.v2.LabelService
 */
export const LabelService: GenService<{
  /**
   * Get list of labels
   *
   * @generated from rpc aquarium.v2.LabelService.List
   */
  list: {
    methodKind: "unary";
    input: typeof LabelServiceListRequestSchema;
    output: typeof LabelServiceListResponseSchema;
  },
  /**
   * Get label by UID
   *
   * @generated from rpc aquarium.v2.LabelService.Get
   */
  get: {
    methodKind: "unary";
    input: typeof LabelServiceGetRequestSchema;
    output: typeof LabelServiceGetResponseSchema;
  },
  /**
   * Create new label
   * Not only admin users can create labels, but also regular users can create temporary
   * editable labels.
   *
   * @generated from rpc aquarium.v2.LabelService.Create
   */
  create: {
    methodKind: "unary";
    input: typeof LabelServiceCreateRequestSchema;
    output: typeof LabelServiceCreateResponseSchema;
  },
  /**
   * Update existing label ONLY with version = 0
   *
   * @generated from rpc aquarium.v2.LabelService.Update
   */
  update: {
    methodKind: "unary";
    input: typeof LabelServiceUpdateRequestSchema;
    output: typeof LabelServiceUpdateResponseSchema;
  },
  /**
   * Remove label by UID
   *
   * @generated from rpc aquarium.v2.LabelService.Remove
   */
  remove: {
    methodKind: "unary";
    input: typeof LabelServiceRemoveRequestSchema;
    output: typeof LabelServiceRemoveResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_aquarium_v2_label, 0);

