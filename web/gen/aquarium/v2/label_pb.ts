// Copyright 2025 Adobe. All rights reserved.
// This file is licensed to you under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License. You may obtain a copy
// of the License at http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
// OF ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.

// Author: Sergei Parshev (@sparshev)

// @generated by protoc-gen-es v2.6.1 with parameter "target=ts"
// @generated from file aquarium/v2/label.proto (package aquarium.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Authentication } from "./common_pb";
import { file_aquarium_v2_common } from "./common_pb";
import { file_aquarium_v2_rbac } from "./rbac_pb";
import { file_aquarium_v2_ui_options } from "./ui_options_pb";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file aquarium/v2/label.proto.
 */
export const file_aquarium_v2_label: GenFile = /*@__PURE__*/
  fileDesc("ChdhcXVhcml1bS92Mi9sYWJlbC5wcm90bxILYXF1YXJpdW0udjIi2QEKBUxhYmVsEhMKA3VpZBgBIAEoCUIGmrUYAggBEjYKCmNyZWF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgaatRgCCAESDAoEbmFtZRgDIAEoCRIPCgd2ZXJzaW9uGAQgASgFEjEKC2RlZmluaXRpb25zGAUgAygLMhwuYXF1YXJpdW0udjIuTGFiZWxEZWZpbml0aW9uEikKCG1ldGFkYXRhGAYgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdDoGkrUYAggBIssBCg9MYWJlbERlZmluaXRpb24SDgoGZHJpdmVyGAEgASgJEigKB29wdGlvbnMYAiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EikKCXJlc291cmNlcxgDIAEoCzIWLmFxdWFyaXVtLnYyLlJlc291cmNlcxI4Cg5hdXRoZW50aWNhdGlvbhgEIAEoCzIbLmFxdWFyaXVtLnYyLkF1dGhlbnRpY2F0aW9uSACIAQE6BpK1GAIIAUIRCg9fYXV0aGVudGljYXRpb24iwQIKCVJlc291cmNlcxISCgVzbG90cxgBIAEoDUgAiAEBEgsKA2NwdRgCIAEoDRILCgNyYW0YAyABKA0SMAoFZGlza3MYBCADKAsyIS5hcXVhcml1bS52Mi5SZXNvdXJjZXMuRGlza3NFbnRyeRIPCgduZXR3b3JrGAUgASgJEhMKC25vZGVfZmlsdGVyGAYgAygJEhQKDG11bHRpdGVuYW5jeRgHIAEoCBIUCgxjcHVfb3ZlcmJvb2sYCCABKAgSFAoMcmFtX292ZXJib29rGAkgASgIEhAKCGxpZmV0aW1lGAogASgJGkgKCkRpc2tzRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhouYXF1YXJpdW0udjIuUmVzb3VyY2VzRGlzazoCOAE6BpK1GAIIAUIICgZfc2xvdHMiYAoNUmVzb3VyY2VzRGlzaxIMCgR0eXBlGAEgASgJEg0KBWxhYmVsGAIgASgJEgwKBHNpemUYAyABKA0SDQoFcmV1c2UYBCABKAgSDQoFY2xvbmUYBSABKAk6BpK1GAIIASJXChdMYWJlbFNlcnZpY2VMaXN0UmVxdWVzdBIRCgRuYW1lGAEgASgJSACIAQESFAoHdmVyc2lvbhgCIAEoCUgBiAEBQgcKBV9uYW1lQgoKCF92ZXJzaW9uIl0KGExhYmVsU2VydmljZUxpc3RSZXNwb25zZRIOCgZzdGF0dXMYASABKAgSDwoHbWVzc2FnZRgCIAEoCRIgCgRkYXRhGAMgAygLMhIuYXF1YXJpdW0udjIuTGFiZWwiKwoWTGFiZWxTZXJ2aWNlR2V0UmVxdWVzdBIRCglsYWJlbF91aWQYASABKAkiXAoXTGFiZWxTZXJ2aWNlR2V0UmVzcG9uc2USDgoGc3RhdHVzGAEgASgIEg8KB21lc3NhZ2UYAiABKAkSIAoEZGF0YRgDIAEoCzISLmFxdWFyaXVtLnYyLkxhYmVsIj4KGUxhYmVsU2VydmljZUNyZWF0ZVJlcXVlc3QSIQoFbGFiZWwYASABKAsyEi5hcXVhcml1bS52Mi5MYWJlbCJfChpMYWJlbFNlcnZpY2VDcmVhdGVSZXNwb25zZRIOCgZzdGF0dXMYASABKAgSDwoHbWVzc2FnZRgCIAEoCRIgCgRkYXRhGAMgASgLMhIuYXF1YXJpdW0udjIuTGFiZWwiLgoZTGFiZWxTZXJ2aWNlUmVtb3ZlUmVxdWVzdBIRCglsYWJlbF91aWQYASABKAkiPQoaTGFiZWxTZXJ2aWNlUmVtb3ZlUmVzcG9uc2USDgoGc3RhdHVzGAEgASgIEg8KB21lc3NhZ2UYAiABKAky/QIKDExhYmVsU2VydmljZRJfCgRMaXN0EiQuYXF1YXJpdW0udjIuTGFiZWxTZXJ2aWNlTGlzdFJlcXVlc3QaJS5hcXVhcml1bS52Mi5MYWJlbFNlcnZpY2VMaXN0UmVzcG9uc2UiCoK1GAYaBFVzZXISUgoDR2V0EiMuYXF1YXJpdW0udjIuTGFiZWxTZXJ2aWNlR2V0UmVxdWVzdBokLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZUdldFJlc3BvbnNlIgASWwoGQ3JlYXRlEiYuYXF1YXJpdW0udjIuTGFiZWxTZXJ2aWNlQ3JlYXRlUmVxdWVzdBonLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZUNyZWF0ZVJlc3BvbnNlIgASWwoGUmVtb3ZlEiYuYXF1YXJpdW0udjIuTGFiZWxTZXJ2aWNlUmVtb3ZlUmVxdWVzdBonLmFxdWFyaXVtLnYyLkxhYmVsU2VydmljZVJlbW92ZVJlc3BvbnNlIgBCRVpDZ2l0aHViLmNvbS9hZG9iZS9hcXVhcml1bS1maXNoL2xpYi9ycGMvcHJvdG8vYXF1YXJpdW0vdjI7YXF1YXJpdW12MmIGcHJvdG8z", [file_google_protobuf_timestamp, file_google_protobuf_struct, file_aquarium_v2_common, file_aquarium_v2_rbac, file_aquarium_v2_ui_options]);

/**
 * Label represents a reproducible environment configuration
 *
 * This one filled by the cluster admin, depends on the needs. Labels could be defined in
 * different drivers and the priority is sequential. Version could be used during request and
 * by default is the latest.
 *
 * Label - is one of the most important part of the system, because it makes the resources
 * reproducible in time. Definitions contains the driver name and configuration, so can be
 * started again and again as much times we need. Versions make possible to update the labels
 * and store the old ones in case we need to run the same environment 10y from now and rebuild
 * the old code revision for example.
 *
 * Labels can't be updated. Once they are stored - they are here to keep the history of
 * environements and make possible to mark build with the specified label version in order to
 * be able to reproduce it later. Also labels can be implemented just by one or multiple
 * drivers. Sometimes it's useful to switch to another provider in case the previous ones are
 * not available or completely used.
 *
 * Combination of Name and Version should be unique.
 *
 * @generated from message aquarium.v2.Label
 */
export type Label = Message<"aquarium.v2.Label"> & {
  /**
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Simple name to identify the Label
   * example: macos1405-xcode161-ci_aws
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * In order to update the labels freely and save the previous Label state for the past builds.
   *
   * @generated from field: int32 version = 4;
   */
  version: number;

  /**
   * List of label definitions that describes required resources, driver and it's options.
   * The order is sequential - so the priority is to the first driver and if it's not
   * available than the next definitions will be used.
   * example:
   *   - driver: vmx
   *     options:
   *       image: winserver2019-vs2019-ci
   *       images:
   *         - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019/winserver2019-VERSION.tar.xz'
   *         - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019-vs2019/winserver2019-vs2019-VERSION.tar.xz'
   *         - url: 'https://artifact-storage/aquarium/image/vmx/winserver2019-vs2019-ci/winserver2019-vs2019-ci-VERSION.tar.xz'
   *     resources:
   *       cpu: 16
   *       ram: 20
   *       disks:
   *         ws:
   *           size: 100
   *           reuse: true
   *       network: nat
   *   - driver: aws
   *     options:
   *       image: aquarium/winserver2019-vs2019-ci-VERSION
   *       instance_type: c6a.4xlarge
   *       security_groups:
   *         - jenkins-worker
   *       userdata_format: ps1
   *     resources:
   *       cpu: 16
   *       ram: 32
   *       disks:
   *         xvdb:
   *           size: 100
   *       network: Name:build-vpc
   *
   * @generated from field: repeated aquarium.v2.LabelDefinition definitions = 5;
   */
  definitions: LabelDefinition[];

  /**
   * Basic metadata to pass to the ApplicationResource
   * example:
   *   JENKINS_AGENT_WORKSPACE: 'D:\'
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message aquarium.v2.Label.
 * Use `create(LabelSchema)` to create a new message.
 */
export const LabelSchema: GenMessage<Label> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 0);

/**
 * LabelDefinition describes how to provide resources
 *
 * Describes Label's ways to provide aa ApplicationResource - it contains name of the driver,
 * it's resource and additional options.
 *
 * @generated from message aquarium.v2.LabelDefinition
 */
export type LabelDefinition = Message<"aquarium.v2.LabelDefinition"> & {
  /**
   * Name of the driver to execute
   *
   * @generated from field: string driver = 1;
   */
  driver: string;

  /**
   * Driver-specific options to execute the environment
   *
   * @generated from field: google.protobuf.Struct options = 2;
   */
  options?: JsonObject;

  /**
   * Resources Driver need to provide for the Label execution
   *
   * @generated from field: aquarium.v2.Resources resources = 3;
   */
  resources?: Resources;

  /**
   * Authentication information to connect - is used by:
   * * ProxySSH gate to allow access to the resource
   *
   * @generated from field: optional aquarium.v2.Authentication authentication = 4;
   */
  authentication?: Authentication;
};

/**
 * Describes the message aquarium.v2.LabelDefinition.
 * Use `create(LabelDefinitionSchema)` to create a new message.
 */
export const LabelDefinitionSchema: GenMessage<LabelDefinition> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 1);

/**
 * Resources defines required compute resources for a label
 *
 * It's used for 2 purposes, in Label definitions to describe the required amount of resources
 * and in Fish to store the currently used resources, so could add and subtract resources.
 *
 * Modificators are used for parallel node usage by different Applications, they are stored
 * for the first Application and used for the others to determine node tenancy/overbook
 * tolerance.
 *
 * Different drivers uses it in different ways to provide quite similar functionality, so it's
 * a good idea to check the driver's wiki page to get some clue on how to create Label def.
 *
 * @generated from message aquarium.v2.Resources
 */
export type Resources = Message<"aquarium.v2.Resources"> & {
  /**
   * Global amount of slots to be filled with ApplicationResources
   *
   * @generated from field: optional uint32 slots = 1;
   */
  slots?: number;

  /**
   * Amount of vCPUs (logical CPU with HT enabled will have 2 per core)
   *
   * @generated from field: uint32 cpu = 2;
   */
  cpu: number;

  /**
   * Amount of RAM in GB
   *
   * @generated from field: uint32 ram = 3;
   */
  ram: number;

  /**
   * Defines disks to attach/clone...
   *
   * @generated from field: map<string, aquarium.v2.ResourcesDisk> disks = 4;
   */
  disks: { [key: string]: ResourcesDisk };

  /**
   * Which network configuration to use for the environment
   *
   * @generated from field: string network = 5;
   */
  network: string;

  /**
   * The list of the Node identifiers to run resource on, supports path wildcards
   * example:
   *   - OS:darwin
   *   - OSVersion:12.*
   *   - Arch:x86_64
   *
   * @generated from field: repeated string node_filter = 6;
   */
  nodeFilter: string[];

  /**
   * Tolerate to run along with the other envs on the same node
   *
   * @generated from field: bool multitenancy = 7;
   */
  multitenancy: boolean;

  /**
   * Tolerate to node CPU overbooking when executed together with other envs
   *
   * @generated from field: bool cpu_overbook = 8;
   */
  cpuOverbook: boolean;

  /**
   * Tolerate to RAM overbooking when executed together with other envs
   *
   * @generated from field: bool ram_overbook = 9;
   */
  ramOverbook: boolean;

  /**
   * Total lifetime of the ApplicationResource in Time Duration (ex. "1h30m30s"). Begins on
   * ApplicationResource create time till deallocate by user or auto deallocate by timeout.
   * If it's empty or "0" then default value from fish node config will be used. If it's
   * negative (ex. "-1s") then the ApplicationResource will live forever or until the user
   * requests deallocate.
   *
   * @generated from field: string lifetime = 10;
   */
  lifetime: string;
};

/**
 * Describes the message aquarium.v2.Resources.
 * Use `create(ResourcesSchema)` to create a new message.
 */
export const ResourcesSchema: GenMessage<Resources> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 2);

/**
 * ResourcesDisk defines disk configuration
 *
 * @generated from message aquarium.v2.ResourcesDisk
 */
export type ResourcesDisk = Message<"aquarium.v2.ResourcesDisk"> & {
  /**
   * Type of the filesystem to create by Fish - usually handled by the formatter of the image
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Volume name will be given to the disk, empty will use the disk key
   *
   * @generated from field: string label = 2;
   */
  label: string;

  /**
   * Amount of disk space in GB for new disk, could not used if clone is set
   *
   * @generated from field: uint32 size = 3;
   */
  size: number;

  /**
   * Do not remove the disk and reuse it for the next resource run
   *
   * @generated from field: bool reuse = 4;
   */
  reuse: boolean;

  /**
   * Clone the snapshot of existing disk instead of creating the new one
   *
   * @generated from field: string clone = 5;
   */
  clone: string;
};

/**
 * Describes the message aquarium.v2.ResourcesDisk.
 * Use `create(ResourcesDiskSchema)` to create a new message.
 */
export const ResourcesDiskSchema: GenMessage<ResourcesDisk> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 3);

/**
 * @generated from message aquarium.v2.LabelServiceListRequest
 */
export type LabelServiceListRequest = Message<"aquarium.v2.LabelServiceListRequest"> & {
  /**
   * Filter the list by name of the label
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Filter the list by version of the label, "last" will return only latest version of labels
   *
   * @generated from field: optional string version = 2;
   */
  version?: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceListRequest.
 * Use `create(LabelServiceListRequestSchema)` to create a new message.
 */
export const LabelServiceListRequestSchema: GenMessage<LabelServiceListRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 4);

/**
 * @generated from message aquarium.v2.LabelServiceListResponse
 */
export type LabelServiceListResponse = Message<"aquarium.v2.LabelServiceListResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: repeated aquarium.v2.Label data = 3;
   */
  data: Label[];
};

/**
 * Describes the message aquarium.v2.LabelServiceListResponse.
 * Use `create(LabelServiceListResponseSchema)` to create a new message.
 */
export const LabelServiceListResponseSchema: GenMessage<LabelServiceListResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 5);

/**
 * @generated from message aquarium.v2.LabelServiceGetRequest
 */
export type LabelServiceGetRequest = Message<"aquarium.v2.LabelServiceGetRequest"> & {
  /**
   * @generated from field: string label_uid = 1;
   */
  labelUid: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceGetRequest.
 * Use `create(LabelServiceGetRequestSchema)` to create a new message.
 */
export const LabelServiceGetRequestSchema: GenMessage<LabelServiceGetRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 6);

/**
 * @generated from message aquarium.v2.LabelServiceGetResponse
 */
export type LabelServiceGetResponse = Message<"aquarium.v2.LabelServiceGetResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: aquarium.v2.Label data = 3;
   */
  data?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceGetResponse.
 * Use `create(LabelServiceGetResponseSchema)` to create a new message.
 */
export const LabelServiceGetResponseSchema: GenMessage<LabelServiceGetResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 7);

/**
 * @generated from message aquarium.v2.LabelServiceCreateRequest
 */
export type LabelServiceCreateRequest = Message<"aquarium.v2.LabelServiceCreateRequest"> & {
  /**
   * @generated from field: aquarium.v2.Label label = 1;
   */
  label?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceCreateRequest.
 * Use `create(LabelServiceCreateRequestSchema)` to create a new message.
 */
export const LabelServiceCreateRequestSchema: GenMessage<LabelServiceCreateRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 8);

/**
 * @generated from message aquarium.v2.LabelServiceCreateResponse
 */
export type LabelServiceCreateResponse = Message<"aquarium.v2.LabelServiceCreateResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: aquarium.v2.Label data = 3;
   */
  data?: Label;
};

/**
 * Describes the message aquarium.v2.LabelServiceCreateResponse.
 * Use `create(LabelServiceCreateResponseSchema)` to create a new message.
 */
export const LabelServiceCreateResponseSchema: GenMessage<LabelServiceCreateResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 9);

/**
 * @generated from message aquarium.v2.LabelServiceRemoveRequest
 */
export type LabelServiceRemoveRequest = Message<"aquarium.v2.LabelServiceRemoveRequest"> & {
  /**
   * @generated from field: string label_uid = 1;
   */
  labelUid: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceRemoveRequest.
 * Use `create(LabelServiceRemoveRequestSchema)` to create a new message.
 */
export const LabelServiceRemoveRequestSchema: GenMessage<LabelServiceRemoveRequest> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 10);

/**
 * @generated from message aquarium.v2.LabelServiceRemoveResponse
 */
export type LabelServiceRemoveResponse = Message<"aquarium.v2.LabelServiceRemoveResponse"> & {
  /**
   * @generated from field: bool status = 1;
   */
  status: boolean;

  /**
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message aquarium.v2.LabelServiceRemoveResponse.
 * Use `create(LabelServiceRemoveResponseSchema)` to create a new message.
 */
export const LabelServiceRemoveResponseSchema: GenMessage<LabelServiceRemoveResponse> = /*@__PURE__*/
  messageDesc(file_aquarium_v2_label, 11);

/**
 * LabelService handles label management operations
 *
 * @generated from service aquarium.v2.LabelService
 */
export const LabelService: GenService<{
  /**
   * Get list of labels
   *
   * @generated from rpc aquarium.v2.LabelService.List
   */
  list: {
    methodKind: "unary";
    input: typeof LabelServiceListRequestSchema;
    output: typeof LabelServiceListResponseSchema;
  },
  /**
   * Get label by UID
   *
   * @generated from rpc aquarium.v2.LabelService.Get
   */
  get: {
    methodKind: "unary";
    input: typeof LabelServiceGetRequestSchema;
    output: typeof LabelServiceGetResponseSchema;
  },
  /**
   * Create new label
   *
   * @generated from rpc aquarium.v2.LabelService.Create
   */
  create: {
    methodKind: "unary";
    input: typeof LabelServiceCreateRequestSchema;
    output: typeof LabelServiceCreateResponseSchema;
  },
  /**
   * Remove label by UID
   *
   * @generated from rpc aquarium.v2.LabelService.Remove
   */
  remove: {
    methodKind: "unary";
    input: typeof LabelServiceRemoveRequestSchema;
    output: typeof LabelServiceRemoveResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_aquarium_v2_label, 0);

