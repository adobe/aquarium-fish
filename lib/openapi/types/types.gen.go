// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package types

import (
	"time"

	"github.com/adobe/aquarium-fish/lib/crypt"
	"github.com/adobe/aquarium-fish/lib/util"
	openapi_types "github.com/oapi-codegen/runtime/types"
	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/host"
	"github.com/shirou/gopsutil/v4/mem"
	"github.com/shirou/gopsutil/v4/net"
)

const (
	Basic_authScopes = "basic_auth.Scopes"
)

// Defines values for ApplicationStatus.
const (
	ApplicationStatusALLOCATED   ApplicationStatus = "ALLOCATED"
	ApplicationStatusDEALLOCATE  ApplicationStatus = "DEALLOCATE"
	ApplicationStatusDEALLOCATED ApplicationStatus = "DEALLOCATED"
	ApplicationStatusELECTED     ApplicationStatus = "ELECTED"
	ApplicationStatusERROR       ApplicationStatus = "ERROR"
	ApplicationStatusNEW         ApplicationStatus = "NEW"
	ApplicationStatusRECALLED    ApplicationStatus = "RECALLED"
)

// Defines values for DataGetListParamsFormat.
const (
	DataGetListParamsFormatEnv  DataGetListParamsFormat = "env"
	DataGetListParamsFormatJson DataGetListParamsFormat = "json"
)

// Defines values for DataGetParamsFormat.
const (
	DataGetParamsFormatEnv  DataGetParamsFormat = "env"
	DataGetParamsFormatJson DataGetParamsFormat = "json"
)

// Application Allocation request created by the user. Each node votes for the availability to allocate the ApplicationResource and the cluster choose which one node will actually do the work.
type Application struct {
	UID       ApplicationUID     `json:"UID"`
	CreatedAt time.Time          `json:"created_at"`
	LabelUID  openapi_types.UUID `json:"label_UID" yaml:"label_UID"`

	// Metadata Additional metadata in JSON format (can't override Label metadata)
	Metadata  util.UnparsedJSON `json:"metadata"`
	OwnerName string            `json:"owner_name"`
}

// ApplicationResource Managed instance definition to be able to properly restore the state during the cluster node restart. Also contains additional info about the instance, for example user requested metadata, which is available for the instance through the `Meta API`.
// Could be created and updated only by the node which won the Application execution.
type ApplicationResource struct {
	UID            ApplicationResourceUID `json:"UID"`
	ApplicationUID openapi_types.UUID     `json:"application_UID" yaml:"application_UID"`

	// Authentication Authentication information to enable connecting to the machine.
	Authentication  *Authentication `json:"authentication,omitempty"`
	CreatedAt       time.Time       `json:"created_at"`
	DefinitionIndex int             `json:"definition_index"`

	// HwAddr MAC or any other type of network address which will allow to properly identify the node through network interaction.
	HwAddr string `json:"hw_addr"`

	// Identifier Unique for driver identifier of the instance which can be used to find it later.
	Identifier string `json:"identifier"`

	// IpAddr Is a weak current network IP address of the instance, usually gathered based on the `hw_addr`.
	IpAddr   string             `json:"ip_addr"`
	LabelUID openapi_types.UUID `json:"label_UID" yaml:"label_UID"`

	// Metadata Combined Application and Label metadata (in this order) to make it available through `Meta API` to the instance.
	Metadata util.UnparsedJSON  `json:"metadata"`
	NodeUID  openapi_types.UUID `json:"node_UID" yaml:"node_UID"`

	// Timeout Calculated during allocation time of when the Resource have to die anyway
	Timeout   *time.Time `json:"timeout,omitempty"`
	UpdatedAt time.Time  `json:"updated_at"`
}

// ApplicationResourceAccess An accessor entry to be able to identify and look up different (currently running) resources.
// Used to enable SSH pass-through.
type ApplicationResourceAccess struct {
	UID ApplicationResourceAccessUID `json:"UID"`

	// Address Address (host:port) to help user to connect to right proxyssh.
	Address                string             `json:"address"`
	ApplicationResourceUID openapi_types.UUID `json:"application_resource_UID" yaml:"application_resource_UID"`
	CreatedAt              time.Time          `json:"created_at"`

	// Key SSH key could be used instead of password to access the system.
	Key string `json:"key"`

	// Password The password to use when logging into the fish node.
	Password string `json:"password"`

	// Username The username to use when logging into the fish node.
	Username string `json:"username"`
}

// ApplicationResourceAccessUID defines model for ApplicationResourceAccessUID.
type ApplicationResourceAccessUID = openapi_types.UUID

// ApplicationResourceUID defines model for ApplicationResourceUID.
type ApplicationResourceUID = openapi_types.UUID

// ApplicationState The state of the Application - it goes through graph of states, so this object stores the info when the Application comes to this state and the last one describes the current state of the Application.
type ApplicationState struct {
	UID            ApplicationStateUID `json:"UID"`
	ApplicationUID openapi_types.UUID  `json:"application_UID" yaml:"application_UID"`
	CreatedAt      time.Time           `json:"created_at"`

	// Description Additional information for the state
	Description string            `json:"description"`
	Status      ApplicationStatus `json:"status"`
}

// ApplicationStateUID defines model for ApplicationStateUID.
type ApplicationStateUID = openapi_types.UUID

// ApplicationStatus defines model for ApplicationStatus.
type ApplicationStatus string

// ApplicationTask Is needed to execute some sort of async action on the Application. For example snapshot operation, because the request could get from anywhere. Usually app tasks are not a part of standard Application state graph and could be not executed if the Applicationresource is destroyed.
// Results are filled by the executor of the task and really depends on what kind of operation is executed and really depends on the driver - it could support the task or not.
// It could be created by any Node but updated by the one which won the Application execution.
type ApplicationTask struct {
	UID            ApplicationTaskUID `json:"UID"`
	ApplicationUID openapi_types.UUID `json:"application_UID" yaml:"application_UID"`
	CreatedAt      time.Time          `json:"created_at"`

	// Options JSON object with additional options
	Options util.UnparsedJSON `json:"options"`

	// Result JSON object with the results of task execution
	Result util.UnparsedJSON `json:"result"`

	// Task Identifier of the task
	Task      string            `json:"task"`
	UpdatedAt time.Time         `json:"updated_at"`
	When      ApplicationStatus `json:"when"`
}

// ApplicationTaskUID defines model for ApplicationTaskUID.
type ApplicationTaskUID = openapi_types.UUID

// ApplicationUID defines model for ApplicationUID.
type ApplicationUID = openapi_types.UUID

// Authentication Authentication information to enable connecting to the machine.
type Authentication struct {
	// Key SSH private key to use instead of password to login into the ApplicationResource.
	Key string `json:"key"`

	// Password The password to login into the ApplicationResource.
	Password string `json:"password"`

	// Port TCP port to connect with SSH client.
	Port int `json:"port"`

	// Username The username to login into the ApplicationResource.
	Username string `json:"username"`
}

// Label This one filled by the cluster admin, depends on the needs. Labels could be defined in different drivers and the priority is sequential. Version could be used during request and by default is the latest.
// Label - is one of the most important part of the system, because it makes the resources reproducible in time. Definitions contains the driver name and configuration, so can be started again and again as much times we need. Versions make possible to update the labels and store the old ones in case we need to run the same environment 10y from now and rebuild the old code revision for example.
// Labels can't be updated. Once they are stored - they are here to keep the history of environements and make possible to mark build with the specified label version in order to be able to reproduce it later. Also labels can be implemented just by one or multiple drivers. Sometimes it's useful to switch to another provider in case the previous ones are not available or completely used.
type Label struct {
	UID       LabelUID  `json:"UID"`
	CreatedAt time.Time `json:"created_at"`

	// Definitions List of label definitions that describes required resources, driver and it's options.
	// The order is sequential - so the priority is to the first driver and if it's not
	// available than the next definitions will be used.
	Definitions LabelDefinitions `json:"definitions"`

	// Metadata Basic metadata to pass to the ApplicationResource
	Metadata util.UnparsedJSON `json:"metadata"`

	// Name Simple name to identify the Label
	Name string `json:"name"`

	// Version In order to update the labels freely and save the previous Label state for the past builds.
	Version int `json:"version"`
}

// LabelDefinition Describes Label's ways to provide aa ApplicationResource - it contains name of the driver, it's resource and additional options.
type LabelDefinition struct {
	// Authentication Authentication information to enable connecting to the machine.
	Authentication *Authentication `json:"authentication,omitempty"`

	// Driver Name of the driver to execute
	Driver string `json:"driver"`

	// Options Driver-specific options to execute the environment
	Options util.UnparsedJSON `json:"options"`

	// Resources It's used for 2 purposes, in Label definitions to describe the required amount of resources and in Fish to store the currently used resources, so could add and subtract resources.
	// Modificators are used for parallel node usage by different Applications, they are stored for the first Application and used for the others to determine node tenancy/overbook tolerance.
	// Different drivers uses it in different ways to provide quite similar functionality, so it's a good idea to check the driver's wiki page to get some clue on how to create Label def.
	Resources Resources `json:"resources"`
}

// LabelDefinitions List of label definitions that describes required resources, driver and it's options.
// The order is sequential - so the priority is to the first driver and if it's not
// available than the next definitions will be used.
type LabelDefinitions = []LabelDefinition

// LabelUID defines model for LabelUID.
type LabelUID = openapi_types.UUID

// Node Each node need to report it's status and ensure there is no duplications and to perform the cluster worker election process properly.
// Could be created by the node itself and updated by the same node.
type Node struct {
	UID NodeUID `json:"UID"`

	// Address External address to reach the Node from outside
	Address   string    `json:"address"`
	CreatedAt time.Time `json:"created_at"`

	// Definition Contains technical information about the node
	Definition NodeDefinition `json:"definition"`

	// Location Where the Node is located
	Location string `json:"location"`

	// Name Unique name of the Node
	Name string `gorm:"unique" json:"name"`

	// Pubkey The node public key to verify on secondary connections and signatures
	Pubkey *[]byte `gorm:"unique" json:"pubkey,omitempty"`

	// UpdatedAt This field is used as ping, so the cluster knows the Node is alive.
	UpdatedAt time.Time `json:"updated_at"`
}

// NodeDefinition Contains technical information about the node
type NodeDefinition struct {
	Cpu    []cpu.InfoStat             `json:"cpu"`
	Disks  map[string]*disk.UsageStat `json:"disks"`
	Host   *host.InfoStat             `json:"host"`
	Memory *mem.VirtualMemoryStat     `json:"memory"`
	Nets   []net.InterfaceStat        `json:"nets"`
}

// NodeUID defines model for NodeUID.
type NodeUID = openapi_types.UUID

// Permission Defines a permission that can be granted to roles.
type Permission struct {
	// Action Action allowed on the resource (e.g., read, write, delete)
	Action string `json:"action"`

	// Resource Resource type or specific resource ID this permission applies to
	Resource string `json:"resource"`
}

// Resources It's used for 2 purposes, in Label definitions to describe the required amount of resources and in Fish to store the currently used resources, so could add and subtract resources.
// Modificators are used for parallel node usage by different Applications, they are stored for the first Application and used for the others to determine node tenancy/overbook tolerance.
// Different drivers uses it in different ways to provide quite similar functionality, so it's a good idea to check the driver's wiki page to get some clue on how to create Label def.
type Resources struct {
	// Cpu Amount of vCPUs (logical CPU with HT enabled will have 2 per core)
	Cpu uint `json:"cpu"`

	// CpuOverbook Tolerate to node CPU overbooking when executed together with other envs
	CpuOverbook bool                     `json:"cpu_overbook"`
	Disks       map[string]ResourcesDisk `json:"disks"`

	// Lifetime Total lifetime of the ApplicationResource in Time Duration (ex. "1h30m30s"). Begins on
	// ApplicationResource create time till deallocate by user or auto deallocate by timeout.
	// If it's empty or "0" then default value from fish node config will be used. If it's
	// negative (ex. "-1s") then the ApplicationResource will live forever or until the user
	// requests deallocate.
	Lifetime string `json:"lifetime"`

	// Multitenancy Tolerate to run along with the other envs on the same node
	Multitenancy bool `json:"multitenancy"`

	// Network Which network configuration to use for the environment
	Network string `json:"network"`

	// NodeFilter The list of the Node identifiers to run resource on, supports path wildcards
	NodeFilter []string `json:"node_filter"`

	// Ram Amount of RAM in GB
	Ram uint `json:"ram"`

	// RamOverbook Tolerate to RAM overbooking when executed together with other envs
	RamOverbook bool `json:"ram_overbook"`

	// Slots Global amount of slots to be filled with ApplicationResources
	Slots *uint `json:"slots,omitempty"`
}

// ResourcesDisk Defines disk to attach/clone...
type ResourcesDisk struct {
	// Clone Clone the snapshot of existing disk instead of creating the new one
	Clone string `json:"clone"`

	// Label Volume name will be given to the disk, empty will use the disk key
	Label string `json:"label"`

	// Reuse Do not remove the disk and reuse it for the next resource run
	Reuse bool `json:"reuse"`

	// Size Amount of disk space in GB for new disk, could not used if clone is set
	Size uint `json:"size"`

	// Type Type of the filesystem to create
	Type string `json:"type"`
}

// Role Defines a role in the RBAC system with associated permissions.
type Role struct {
	CreatedAt time.Time `json:"created_at"`

	// Name Unique name of the role
	Name string `json:"name"`

	// Permissions List of permissions granted to this role
	Permissions []Permission `json:"permissions"`
	UpdatedAt   time.Time    `json:"updated_at"`
}

// ServiceMapping Used to properly define the allowed external services and possible redirects for them ( useful when needed to achive proper bottleneck-free DR). The structure allows to make query with finding the most relevant value based on application and location, in case there is no specific values - the cluster defaults could be used.
type ServiceMapping struct {
	UID ServiceMappingUID `json:"UID"`

	// ApplicationUID Optional, if need to override the cluster-wide redirects
	ApplicationUID openapi_types.UUID `gorm:"uniqueIndex:idx_location_service_app_uniq" json:"application_UID" yaml:"application_UID"`
	CreatedAt      time.Time          `json:"created_at"`
	Location       string             `gorm:"uniqueIndex:idx_location_service_app_uniq" json:"location"`

	// Redirect FQDN or IP address of where to rediect the service request
	Redirect string `json:"redirect"`

	// Service FQDN or IP address of the requested service
	Service string `gorm:"uniqueIndex:idx_location_service_app_uniq" json:"service"`
}

// ServiceMappingUID defines model for ServiceMappingUID.
type ServiceMappingUID = openapi_types.UUID

// User Contains user information including roles and permissions. The `admin` user is created during the first cluster start and prints credentials to stderr.
// Can be created by any node and updated by any node with appropriate permissions.
type User struct {
	CreatedAt time.Time  `json:"created_at"`
	Hash      crypt.Hash `json:"hash"`
	Name      UserName   `json:"name"`

	// Roles List of role names assigned to the user
	Roles     []string  `json:"roles"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UserAPIPassword Purely API-only special user object to use during User create operation - it allows to set the required user password or receive the automatically generated one.
type UserAPIPassword struct {
	CreatedAt time.Time   `json:"created_at"`
	Hash      *crypt.Hash `json:"hash,omitempty"`
	Name      UserName    `json:"name"`

	// Password Clear-text password to set for new user or to get the autogenerated one
	Password  string    `json:"password"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UserName defines model for UserName.
type UserName = string

// Vote When Application becomes available for the node it starts to vote to notify the cluster about its availability. Votes are basically "yes" or "no" and could take a number of rounds depends on the cluster voting and election rules. Votes are not stored in DB and lives only in-memory.
type Vote struct {
	UID            VoteUID            `json:"UID"`
	ApplicationUID openapi_types.UUID `json:"application_UID" yaml:"application_UID"`

	// Available Node places answer to the Vote for the Application's definitions, the number represents the first available index of the definition which fits the node available resources. In case it's `-1` then node can't run any of the definitions.
	Available int                `json:"available"`
	CreatedAt time.Time          `json:"created_at"`
	NodeUID   openapi_types.UUID `json:"node_UID" yaml:"node_UID"`

	// Rand The last resort to figure out for the winner.
	Rand uint32 `json:"rand"`

	// Round Round of the election, because it can take a number of rounds to figure out the Only One.
	Round uint16 `json:"round"`

	// RuleResult The custom rule result is needed to store the custom rule decision
	RuleResult uint32 `json:"rule_result"`
}

// VoteUID defines model for VoteUID.
type VoteUID = openapi_types.UUID

// LabelListGetParams defines parameters for LabelListGet.
type LabelListGetParams struct {
	// Name Filter the list by name of the label
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Version Filter the list by version of the label, "last" will return only latest versions of labels
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// NodeThisMaintenanceGetParams defines parameters for NodeThisMaintenanceGet.
type NodeThisMaintenanceGetParams struct {
	// Enable Enable or disable maintenance mode
	Enable *bool `form:"enable,omitempty" json:"enable,omitempty"`

	// Shutdown Safely stops the Node. It will wait in maintenance mode until all the Applicaions are
	// done and then exit. If Node deployed as a service - then will be restarted immediately,
	// otherwise will just stop. Could be cancelled by stop=false.
	Shutdown *bool `form:"shutdown,omitempty" json:"shutdown,omitempty"`

	// ShutdownDelay How much Node should wait in maintenance mode before exit (ex. "1h10m30s")
	ShutdownDelay *string `form:"shutdown_delay,omitempty" json:"shutdown_delay,omitempty"`
}

// UserRolesPostJSONBody defines parameters for UserRolesPost.
type UserRolesPostJSONBody = []string

// DataGetListParams defines parameters for DataGetList.
type DataGetListParams struct {
	// Format Set the return format
	Format *DataGetListParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Prefix Additional prefix for the key path if `format=env`
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`
}

// DataGetListParamsFormat defines parameters for DataGetList.
type DataGetListParamsFormat string

// DataGetParams defines parameters for DataGet.
type DataGetParams struct {
	// Format Set the return format
	Format *DataGetParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Prefix Additional prefix for the key path if `format=env`
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`
}

// DataGetParamsFormat defines parameters for DataGet.
type DataGetParamsFormat string

// ApplicationCreatePostJSONRequestBody defines body for ApplicationCreatePost for application/json ContentType.
type ApplicationCreatePostJSONRequestBody = Application

// ApplicationTaskCreatePostJSONRequestBody defines body for ApplicationTaskCreatePost for application/json ContentType.
type ApplicationTaskCreatePostJSONRequestBody = ApplicationTask

// LabelCreatePostJSONRequestBody defines body for LabelCreatePost for application/json ContentType.
type LabelCreatePostJSONRequestBody = Label

// RoleCreateUpdatePostJSONRequestBody defines body for RoleCreateUpdatePost for application/json ContentType.
type RoleCreateUpdatePostJSONRequestBody = Role

// ServiceMappingCreatePostJSONRequestBody defines body for ServiceMappingCreatePost for application/json ContentType.
type ServiceMappingCreatePostJSONRequestBody = ServiceMapping

// UserCreateUpdatePostJSONRequestBody defines body for UserCreateUpdatePost for application/json ContentType.
type UserCreateUpdatePostJSONRequestBody = UserAPIPassword

// UserRolesPostJSONRequestBody defines body for UserRolesPost for application/json ContentType.
type UserRolesPostJSONRequestBody = UserRolesPostJSONBody
