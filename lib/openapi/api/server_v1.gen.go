// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	auth "github.com/adobe/aquarium-fish/lib/auth"
	. "github.com/adobe/aquarium-fish/lib/openapi/types"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Validate rbac rules automatically, it takes context where finds rbac_service
	// and methods to verify and then replies with the allowed methods
	checkPermission(c echo.Context, methods []string) []string

	// Get list of Applications
	// (GET /api/v1/application/)
	ApplicationListGet(ctx echo.Context) error
	// Create new Application
	// (POST /api/v1/application/)
	ApplicationCreatePost(ctx echo.Context) error
	// Get Application by UID
	// (GET /api/v1/application/{uid})
	ApplicationGet(ctx echo.Context, uid openapi_types.UUID) error
	// Triggers Application deallocate
	// (GET /api/v1/application/{uid}/deallocate)
	ApplicationDeallocateGet(ctx echo.Context, uid openapi_types.UUID) error
	// Get ApplicationResource by Application UID
	// (GET /api/v1/application/{uid}/resource)
	ApplicationResourceGet(ctx echo.Context, uid openapi_types.UUID) error
	// Get ApplicationState of the Application
	// (GET /api/v1/application/{uid}/state)
	ApplicationStateGet(ctx echo.Context, uid openapi_types.UUID) error
	// Get list of the ApplicationTasks
	// (GET /api/v1/application/{uid}/task/)
	ApplicationTaskListGet(ctx echo.Context, uid openapi_types.UUID) error
	// Create new ApplicationTask
	// (POST /api/v1/application/{uid}/task/)
	ApplicationTaskCreatePost(ctx echo.Context, uid openapi_types.UUID) error
	// Get SSH access credentials by ApplicationResource UID
	// (GET /api/v1/applicationresource/{uid}/access)
	ApplicationResourceAccessPut(ctx echo.Context, uid openapi_types.UUID) error
	// Get list of Labels
	// (GET /api/v1/label/)
	LabelListGet(ctx echo.Context, params LabelListGetParams) error
	// Create new Label
	// (POST /api/v1/label/)
	LabelCreatePost(ctx echo.Context) error
	// Delete Label by UID
	// (DELETE /api/v1/label/{uid})
	LabelDelete(ctx echo.Context, uid openapi_types.UUID) error
	// Get Label by UID
	// (GET /api/v1/label/{uid})
	LabelGet(ctx echo.Context, uid openapi_types.UUID) error
	// Get list of Nodes
	// (GET /api/v1/node/)
	NodeListGet(ctx echo.Context) error
	// Get this Node info
	// (GET /api/v1/node/this/)
	NodeThisGet(ctx echo.Context) error
	// Triggers this Node maintenance mode
	// (GET /api/v1/node/this/maintenance)
	NodeThisMaintenanceGet(ctx echo.Context, params NodeThisMaintenanceGetParams) error
	// Shows pprof index page
	// (GET /api/v1/node/this/profiling/)
	NodeThisProfilingIndexGet(ctx echo.Context) error
	// Gives profiling data from pprof
	// (GET /api/v1/node/this/profiling/{handler})
	NodeThisProfilingGet(ctx echo.Context, handler string) error
	// Get list of Roles
	// (GET /api/v1/role/)
	RoleListGet(ctx echo.Context) error
	// Create or update Role
	// (POST /api/v1/role/)
	RoleCreateUpdatePost(ctx echo.Context) error
	// Delete Role by name
	// (DELETE /api/v1/role/{name})
	RoleDelete(ctx echo.Context, name string) error
	// Get Role by name
	// (GET /api/v1/role/{name})
	RoleGet(ctx echo.Context, name string) error
	// Get list of service mappings
	// (GET /api/v1/servicemapping/)
	ServiceMappingListGet(ctx echo.Context) error
	// Create new ServiceMapping
	// (POST /api/v1/servicemapping/)
	ServiceMappingCreatePost(ctx echo.Context) error
	// Delete the ServiceMapping by UID
	// (DELETE /api/v1/servicemapping/{uid})
	ServiceMappingDelete(ctx echo.Context, uid openapi_types.UUID) error
	// Get ServiceMapping by UID
	// (GET /api/v1/servicemapping/{uid})
	ServiceMappingGet(ctx echo.Context, uid openapi_types.UUID) error
	// Get ApplicationTask data
	// (GET /api/v1/task/{task_uid})
	ApplicationTaskGet(ctx echo.Context, taskUid openapi_types.UUID) error
	// Get list of Users
	// (GET /api/v1/user/)
	UserListGet(ctx echo.Context) error
	// Create or update User
	// (POST /api/v1/user/)
	UserCreateUpdatePost(ctx echo.Context) error
	// Get the current User
	// (GET /api/v1/user/me/)
	UserMeGet(ctx echo.Context) error
	// Delete the User by name
	// (DELETE /api/v1/user/{name})
	UserDelete(ctx echo.Context, name string) error
	// Get User by name
	// (GET /api/v1/user/{name})
	UserGet(ctx echo.Context, name string) error
	// Assign roles to user
	// (POST /api/v1/user/{name}/roles)
	UserRolesPost(ctx echo.Context, name string) error
	// Get list of Votes
	// (GET /api/v1/vote/)
	VoteListGet(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApplicationListGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceList,
		auth.ApplicationServiceListAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationListGet(ctx)
	return err
}

// ApplicationCreatePost converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationCreatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceCreate,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationCreatePost(ctx)
	return err
}

// ApplicationGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceGet,
		auth.ApplicationServiceGetAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationGet(ctx, uid)
	return err
}

// ApplicationDeallocateGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationDeallocateGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceDeallocate,
		auth.ApplicationServiceDeallocateAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationDeallocateGet(ctx, uid)
	return err
}

// ApplicationResourceGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationResourceGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceGetResource,
		auth.ApplicationServiceGetResourceAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationResourceGet(ctx, uid)
	return err
}

// ApplicationStateGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationStateGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceGetState,
		auth.ApplicationServiceGetStateAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationStateGet(ctx, uid)
	return err
}

// ApplicationTaskListGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationTaskListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceListTask,
		auth.ApplicationServiceListTaskAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationTaskListGet(ctx, uid)
	return err
}

// ApplicationTaskCreatePost converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationTaskCreatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationServiceCreateTask,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationTaskCreatePost(ctx, uid)
	return err
}

// ApplicationResourceAccessPut converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationResourceAccessPut(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationResourceService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationResourceServiceAccess,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationResourceAccessPut(ctx, uid)
	return err
}

// LabelListGet converts echo context to params.
func (w *ServerInterfaceWrapper) LabelListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.LabelService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.LabelServiceList,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LabelListGetParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LabelListGet(ctx, params)
	return err
}

// LabelCreatePost converts echo context to params.
func (w *ServerInterfaceWrapper) LabelCreatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.LabelService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.LabelServiceCreate,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LabelCreatePost(ctx)
	return err
}

// LabelDelete converts echo context to params.
func (w *ServerInterfaceWrapper) LabelDelete(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.LabelService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.LabelServiceDelete,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LabelDelete(ctx, uid)
	return err
}

// LabelGet converts echo context to params.
func (w *ServerInterfaceWrapper) LabelGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.LabelService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.LabelServiceGet,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LabelGet(ctx, uid)
	return err
}

// NodeListGet converts echo context to params.
func (w *ServerInterfaceWrapper) NodeListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.NodeService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.NodeServiceList,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NodeListGet(ctx)
	return err
}

// NodeThisGet converts echo context to params.
func (w *ServerInterfaceWrapper) NodeThisGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.NodeService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.NodeServiceGetThis,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NodeThisGet(ctx)
	return err
}

// NodeThisMaintenanceGet converts echo context to params.
func (w *ServerInterfaceWrapper) NodeThisMaintenanceGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.NodeService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.NodeServiceSetMaintenance,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NodeThisMaintenanceGetParams
	// ------------- Optional query parameter "enable" -------------

	err = runtime.BindQueryParameter("form", true, false, "enable", ctx.QueryParams(), &params.Enable)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter enable: %s", err))
	}

	// ------------- Optional query parameter "shutdown" -------------

	err = runtime.BindQueryParameter("form", true, false, "shutdown", ctx.QueryParams(), &params.Shutdown)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shutdown: %s", err))
	}

	// ------------- Optional query parameter "shutdown_delay" -------------

	err = runtime.BindQueryParameter("form", true, false, "shutdown_delay", ctx.QueryParams(), &params.ShutdownDelay)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shutdown_delay: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NodeThisMaintenanceGet(ctx, params)
	return err
}

// NodeThisProfilingIndexGet converts echo context to params.
func (w *ServerInterfaceWrapper) NodeThisProfilingIndexGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.NodeService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.NodeServiceGetProfiling,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NodeThisProfilingIndexGet(ctx)
	return err
}

// NodeThisProfilingGet converts echo context to params.
func (w *ServerInterfaceWrapper) NodeThisProfilingGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.NodeService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.NodeServiceGetProfiling,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "handler" -------------
	var handler string

	err = runtime.BindStyledParameterWithOptions("simple", "handler", ctx.Param("handler"), &handler, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handler: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NodeThisProfilingGet(ctx, handler)
	return err
}

// RoleListGet converts echo context to params.
func (w *ServerInterfaceWrapper) RoleListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.RoleService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.RoleServiceList,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RoleListGet(ctx)
	return err
}

// RoleCreateUpdatePost converts echo context to params.
func (w *ServerInterfaceWrapper) RoleCreateUpdatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.RoleService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.RoleServiceCreate,
		auth.RoleServiceUpdate,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RoleCreateUpdatePost(ctx)
	return err
}

// RoleDelete converts echo context to params.
func (w *ServerInterfaceWrapper) RoleDelete(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.RoleService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.RoleServiceDelete,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RoleDelete(ctx, name)
	return err
}

// RoleGet converts echo context to params.
func (w *ServerInterfaceWrapper) RoleGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.RoleService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.RoleServiceGet,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RoleGet(ctx, name)
	return err
}

// ServiceMappingListGet converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceMappingListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ServiceMappingService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ServiceMappingServiceList,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ServiceMappingListGet(ctx)
	return err
}

// ServiceMappingCreatePost converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceMappingCreatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ServiceMappingService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ServiceMappingServiceCreate,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ServiceMappingCreatePost(ctx)
	return err
}

// ServiceMappingDelete converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceMappingDelete(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ServiceMappingService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ServiceMappingServiceDelete,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ServiceMappingDelete(ctx, uid)
	return err
}

// ServiceMappingGet converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceMappingGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ServiceMappingService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ServiceMappingServiceGet,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "uid" -------------
	var uid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uid", ctx.Param("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ServiceMappingGet(ctx, uid)
	return err
}

// ApplicationTaskGet converts echo context to params.
func (w *ServerInterfaceWrapper) ApplicationTaskGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.ApplicationTaskService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.ApplicationTaskServiceGet,
		auth.ApplicationTaskServiceGetAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "task_uid" -------------
	var taskUid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "task_uid", ctx.Param("task_uid"), &taskUid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_uid: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApplicationTaskGet(ctx, taskUid)
	return err
}

// UserListGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.UserService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.UserServiceList,
		auth.UserServiceListAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserListGet(ctx)
	return err
}

// UserCreateUpdatePost converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreateUpdatePost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.UserService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.UserServiceCreate,
		auth.UserServiceUpdate,
		auth.UserServiceUpdateAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreateUpdatePost(ctx)
	return err
}

// UserMeGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserMeGet(ctx echo.Context) error {
	var err error
	// RBAC validation skipped due to x-rbac extension was not found
	ctx.Set("rbac_service", auth.UserService)
	ctx.Set("rbac_methods", []string{})

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserMeGet(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.UserService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.UserServiceDelete,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, name)
	return err
}

// UserGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.UserService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.UserServiceGet,
		auth.UserServiceGetAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserGet(ctx, name)
	return err
}

// UserRolesPost converts echo context to params.
func (w *ServerInterfaceWrapper) UserRolesPost(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.UserService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.UserServiceAssignRoles,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRolesPost(ctx, name)
	return err
}

// VoteListGet converts echo context to params.
func (w *ServerInterfaceWrapper) VoteListGet(ctx echo.Context) error {
	var err error
	// RBAC validation based on x-rbac extension first defined role/method
	ctx.Set("rbac_service", auth.VoteService)
	allowedMethods := w.Handler.checkPermission(ctx, []string{
		auth.VoteServiceList,
		auth.VoteServiceListAll,
	})
	if len(allowedMethods) == 0 {
		return echo.NewHTTPError(http.StatusForbidden, "Insufficient permissions")
	}
	ctx.Set("rbac_methods", allowedMethods)

	ctx.Set(Basic_authScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VoteListGet(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/application/", wrapper.ApplicationListGet)
	router.POST(baseURL+"/api/v1/application/", wrapper.ApplicationCreatePost)
	router.GET(baseURL+"/api/v1/application/:uid", wrapper.ApplicationGet)
	router.GET(baseURL+"/api/v1/application/:uid/deallocate", wrapper.ApplicationDeallocateGet)
	router.GET(baseURL+"/api/v1/application/:uid/resource", wrapper.ApplicationResourceGet)
	router.GET(baseURL+"/api/v1/application/:uid/state", wrapper.ApplicationStateGet)
	router.GET(baseURL+"/api/v1/application/:uid/task/", wrapper.ApplicationTaskListGet)
	router.POST(baseURL+"/api/v1/application/:uid/task/", wrapper.ApplicationTaskCreatePost)
	router.GET(baseURL+"/api/v1/applicationresource/:uid/access", wrapper.ApplicationResourceAccessPut)
	router.GET(baseURL+"/api/v1/label/", wrapper.LabelListGet)
	router.POST(baseURL+"/api/v1/label/", wrapper.LabelCreatePost)
	router.DELETE(baseURL+"/api/v1/label/:uid", wrapper.LabelDelete)
	router.GET(baseURL+"/api/v1/label/:uid", wrapper.LabelGet)
	router.GET(baseURL+"/api/v1/node/", wrapper.NodeListGet)
	router.GET(baseURL+"/api/v1/node/this/", wrapper.NodeThisGet)
	router.GET(baseURL+"/api/v1/node/this/maintenance", wrapper.NodeThisMaintenanceGet)
	router.GET(baseURL+"/api/v1/node/this/profiling/", wrapper.NodeThisProfilingIndexGet)
	router.GET(baseURL+"/api/v1/node/this/profiling/:handler", wrapper.NodeThisProfilingGet)
	router.GET(baseURL+"/api/v1/role/", wrapper.RoleListGet)
	router.POST(baseURL+"/api/v1/role/", wrapper.RoleCreateUpdatePost)
	router.DELETE(baseURL+"/api/v1/role/:name", wrapper.RoleDelete)
	router.GET(baseURL+"/api/v1/role/:name", wrapper.RoleGet)
	router.GET(baseURL+"/api/v1/servicemapping/", wrapper.ServiceMappingListGet)
	router.POST(baseURL+"/api/v1/servicemapping/", wrapper.ServiceMappingCreatePost)
	router.DELETE(baseURL+"/api/v1/servicemapping/:uid", wrapper.ServiceMappingDelete)
	router.GET(baseURL+"/api/v1/servicemapping/:uid", wrapper.ServiceMappingGet)
	router.GET(baseURL+"/api/v1/task/:task_uid", wrapper.ApplicationTaskGet)
	router.GET(baseURL+"/api/v1/user/", wrapper.UserListGet)
	router.POST(baseURL+"/api/v1/user/", wrapper.UserCreateUpdatePost)
	router.GET(baseURL+"/api/v1/user/me/", wrapper.UserMeGet)
	router.DELETE(baseURL+"/api/v1/user/:name", wrapper.UserDelete)
	router.GET(baseURL+"/api/v1/user/:name", wrapper.UserGet)
	router.POST(baseURL+"/api/v1/user/:name/roles", wrapper.UserRolesPost)
	router.GET(baseURL+"/api/v1/vote/", wrapper.VoteListGet)

}
