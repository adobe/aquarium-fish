/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-streaming. DO NOT EDIT.

package rpc

// This file contains generated routing logic for streaming service
// It extends the main StreamingService with auto-generated request routing methods

import (
	"context"
	"fmt"
	"strings"
	"time"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/adobe/aquarium-fish/lib/auth"
	"github.com/adobe/aquarium-fish/lib/database"
	"github.com/adobe/aquarium-fish/lib/log"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
	rpcutil "github.com/adobe/aquarium-fish/lib/rpc/util"
	typesv2 "github.com/adobe/aquarium-fish/lib/types/aquarium/v2"
)

// subChannels is used to store channels for subscriptions communications
type subChannels struct {
	applicationChannel         chan database.ApplicationSubscriptionEvent
	applicationStateChannel    chan database.ApplicationStateSubscriptionEvent
	applicationResourceChannel chan database.ApplicationResourceSubscriptionEvent
	applicationTaskChannel     chan database.ApplicationTaskSubscriptionEvent
	roleChannel                chan database.RoleSubscriptionEvent
	labelChannel               chan database.LabelSubscriptionEvent
	nodeChannel                chan database.NodeSubscriptionEvent
	userChannel                chan database.UserSubscriptionEvent
}

// requestTypeMapping maps request types to service and method names for RBAC
type serviceMethodInfo struct {
	service string
	method  string
}

var requestTypeMapping = map[string]serviceMethodInfo{
	"ApplicationServiceCreateRequest":       {auth.ApplicationService, auth.ApplicationServiceCreate},
	"ApplicationServiceCreateTaskRequest":   {auth.ApplicationService, auth.ApplicationServiceCreateTask},
	"ApplicationServiceDeallocateRequest":   {auth.ApplicationService, auth.ApplicationServiceDeallocate},
	"ApplicationServiceGetRequest":          {auth.ApplicationService, auth.ApplicationServiceGet},
	"ApplicationServiceGetResourceRequest":  {auth.ApplicationService, auth.ApplicationServiceGetResource},
	"ApplicationServiceGetStateRequest":     {auth.ApplicationService, auth.ApplicationServiceGetState},
	"ApplicationServiceGetTaskRequest":      {auth.ApplicationService, auth.ApplicationServiceGetTask},
	"ApplicationServiceListRequest":         {auth.ApplicationService, auth.ApplicationServiceList},
	"ApplicationServiceListResourceRequest": {auth.ApplicationService, auth.ApplicationServiceListResource},
	"ApplicationServiceListStateRequest":    {auth.ApplicationService, auth.ApplicationServiceListState},
	"ApplicationServiceListTaskRequest":     {auth.ApplicationService, auth.ApplicationServiceListTask},
	"LabelServiceCreateRequest":             {auth.LabelService, auth.LabelServiceCreate},
	"LabelServiceGetRequest":                {auth.LabelService, auth.LabelServiceGet},
	"LabelServiceListRequest":               {auth.LabelService, auth.LabelServiceList},
	"LabelServiceRemoveRequest":             {auth.LabelService, auth.LabelServiceRemove},
	"NodeServiceGetRequest":                 {auth.NodeService, auth.NodeServiceGet},
	"NodeServiceGetThisRequest":             {auth.NodeService, auth.NodeServiceGetThis},
	"NodeServiceListRequest":                {auth.NodeService, auth.NodeServiceList},
	"NodeServiceSetMaintenanceRequest":      {auth.NodeService, auth.NodeServiceSetMaintenance},
	"RoleServiceCreateRequest":              {auth.RoleService, auth.RoleServiceCreate},
	"RoleServiceGetRequest":                 {auth.RoleService, auth.RoleServiceGet},
	"RoleServiceListRequest":                {auth.RoleService, auth.RoleServiceList},
	"RoleServiceRemoveRequest":              {auth.RoleService, auth.RoleServiceRemove},
	"RoleServiceUpdateRequest":              {auth.RoleService, auth.RoleServiceUpdate},
	"UserServiceCreateRequest":              {auth.UserService, auth.UserServiceCreate},
	"UserServiceGetRequest":                 {auth.UserService, auth.UserServiceGet},
	"UserServiceGetMeRequest":               {auth.UserService, auth.UserServiceGetMe},
	"UserServiceListRequest":                {auth.UserService, auth.UserServiceList},
	"UserServiceRemoveRequest":              {auth.UserService, auth.UserServiceRemove},
	"UserServiceUpdateRequest":              {auth.UserService, auth.UserServiceUpdate},
}

// routeApplicationServiceRequest routes applicationService service requests
func (s *StreamingService) routeApplicationServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "ApplicationServiceCreateRequest":
		var req aquariumv2.ApplicationServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}
		// Cache permission for the owner (creator) of the application
		if resp.Msg.Status && resp.Msg.Data != nil {
			userName := rpcutil.GetUserName(ctx)
			appUID := stringToUUID(resp.Msg.Data.Uid)
			s.permissionCache.GrantAccess(userName, appUID)
			logger := log.WithFunc("rpc", "routeApplicationServiceRequest")
			logger.Debug("Streaming: Cached permission for app creator", "user", userName, "app_uid", appUID)
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceCreateTaskRequest":
		var req aquariumv2.ApplicationServiceCreateTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.CreateTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceDeallocateRequest":
		var req aquariumv2.ApplicationServiceDeallocateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Deallocate(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetRequest":
		var req aquariumv2.ApplicationServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetResourceRequest":
		var req aquariumv2.ApplicationServiceGetResourceRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetResource(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetStateRequest":
		var req aquariumv2.ApplicationServiceGetStateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetState(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetTaskRequest":
		var req aquariumv2.ApplicationServiceGetTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListRequest":
		var req aquariumv2.ApplicationServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListResourceRequest":
		var req aquariumv2.ApplicationServiceListResourceRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.ListResource(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListStateRequest":
		var req aquariumv2.ApplicationServiceListStateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.ListState(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListTaskRequest":
		var req aquariumv2.ApplicationServiceListTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.ListTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported applicationService request type: %s", requestType))
	}
}

// routeLabelServiceRequest routes labelService service requests
func (s *StreamingService) routeLabelServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "LabelServiceCreateRequest":
		var req aquariumv2.LabelServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceGetRequest":
		var req aquariumv2.LabelServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceListRequest":
		var req aquariumv2.LabelServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceRemoveRequest":
		var req aquariumv2.LabelServiceRemoveRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Remove(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported labelService request type: %s", requestType))
	}
}

// routeNodeServiceRequest routes nodeService service requests
func (s *StreamingService) routeNodeServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "NodeServiceGetRequest":
		var req aquariumv2.NodeServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "NodeServiceGetThisRequest":
		var req aquariumv2.NodeServiceGetThisRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.GetThis(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "NodeServiceListRequest":
		var req aquariumv2.NodeServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "NodeServiceSetMaintenanceRequest":
		var req aquariumv2.NodeServiceSetMaintenanceRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.SetMaintenance(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported nodeService request type: %s", requestType))
	}
}

// routeRoleServiceRequest routes roleService service requests
func (s *StreamingService) routeRoleServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "RoleServiceCreateRequest":
		var req aquariumv2.RoleServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceGetRequest":
		var req aquariumv2.RoleServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceListRequest":
		var req aquariumv2.RoleServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceRemoveRequest":
		var req aquariumv2.RoleServiceRemoveRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Remove(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceUpdateRequest":
		var req aquariumv2.RoleServiceUpdateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Update(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported roleService request type: %s", requestType))
	}
}

// routeUserServiceRequest routes userService service requests
func (s *StreamingService) routeUserServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "UserServiceCreateRequest":
		var req aquariumv2.UserServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceGetRequest":
		var req aquariumv2.UserServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceGetMeRequest":
		var req aquariumv2.UserServiceGetMeRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.GetMe(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceListRequest":
		var req aquariumv2.UserServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceRemoveRequest":
		var req aquariumv2.UserServiceRemoveRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Remove(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceUpdateRequest":
		var req aquariumv2.UserServiceUpdateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Update(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported userService request type: %s", requestType))
	}
}

// routeRequest routes a request to the appropriate service handler
func (s *StreamingService) routeRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	logger := log.WithFunc("rpc", "routeRequest")
	logger.Debug("Streaming: Routing request type", "req_type", requestType)

	// Route to the appropriate service using generated routing methods
	switch {
	case strings.HasPrefix(requestType, "ApplicationService"):
		return s.routeApplicationServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "LabelService"):
		return s.routeLabelServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "NodeService"):
		return s.routeNodeServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "RoleService"):
		return s.routeRoleServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "UserService"):
		return s.routeUserServiceRequest(ctx, requestType, requestData)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported request type: %s", requestType))
	}
}

// Subscription-related helper methods
// relayApplicationNotifications relays application notifications with immediate disconnect on overflow
func (s *StreamingService) relayApplicationNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.ApplicationSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("Application relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeApplication(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("Application relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("Application relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.applicationChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("Application channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayApplicationStateNotifications relays applicationState notifications with immediate disconnect on overflow
func (s *StreamingService) relayApplicationStateNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.ApplicationStateSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationStateNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationState relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeApplicationState(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationState relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationState relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.applicationStateChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("ApplicationState channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayApplicationResourceNotifications relays applicationResource notifications with immediate disconnect on overflow
func (s *StreamingService) relayApplicationResourceNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.ApplicationResourceSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationResourceNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationResource relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeApplicationResource(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationResource relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationResource relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.applicationResourceChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("ApplicationResource channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayApplicationTaskNotifications relays applicationTask notifications with immediate disconnect on overflow
func (s *StreamingService) relayApplicationTaskNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.ApplicationTaskSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationTaskNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationTask relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeApplicationTask(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationTask relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationTask relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.applicationTaskChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("ApplicationTask channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayRoleNotifications relays role notifications with immediate disconnect on overflow
func (s *StreamingService) relayRoleNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.RoleSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayRoleNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("Role relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeRole(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("Role relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("Role relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.roleChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("Role channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayLabelNotifications relays label notifications with immediate disconnect on overflow
func (s *StreamingService) relayLabelNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.LabelSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayLabelNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("Label relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeLabel(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("Label relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("Label relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.labelChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("Label channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayNodeNotifications relays node notifications with immediate disconnect on overflow
func (s *StreamingService) relayNodeNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.NodeSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayNodeNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("Node relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeNode(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("Node relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("Node relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.nodeChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("Node channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayUserNotifications relays user notifications with immediate disconnect on overflow
func (s *StreamingService) relayUserNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel chan database.UserSubscriptionEvent) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayUserNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("User relay goroutine panic", "panic", r)
		}
	}()

	// Don't forget to unsubscribe from database when the relay is completed
	defer func() {
		s.fish.DB().UnsubscribeUser(ctx, dbChannel)
		close(dbChannel) // Close the channel we created
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("User relay stopping due to context cancellation")
			return
		case event, ok := <-dbChannel:
			if !ok {
				logger.Debug("User relay stopping due to closed database channel")
				return
			}

			// Try to send with a short timeout - disconnect if client can't keep up
			select {
			case sub.channels.userChannel <- event:
				// Successfully sent notification
			case <-time.After(200 * time.Millisecond):
				logger.Error("User channel send timeout - client cannot keep up, disconnecting")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// setupChannels sets the channels for the database changes
func (s *StreamingService) setupChannels() *subChannels {
	return &subChannels{
		applicationChannel:         make(chan database.ApplicationSubscriptionEvent, 100),
		applicationStateChannel:    make(chan database.ApplicationStateSubscriptionEvent, 100),
		applicationResourceChannel: make(chan database.ApplicationResourceSubscriptionEvent, 100),
		applicationTaskChannel:     make(chan database.ApplicationTaskSubscriptionEvent, 100),
		roleChannel:                make(chan database.RoleSubscriptionEvent, 100),
		labelChannel:               make(chan database.LabelSubscriptionEvent, 100),
		nodeChannel:                make(chan database.NodeSubscriptionEvent, 100),
		userChannel:                make(chan database.UserSubscriptionEvent, 100),
	}
}

// listenChannels listen for database channels
func (s *StreamingService) listenChannels(sub *subscription, ctx, subCtx context.Context) {
	logger := log.WithFunc("rpc", "listenChannels").With("subs_uid", sub.id)
	// Signal completion when this goroutine exits
	defer sub.listenChannelsWg.Done()

	defer func() {
		if r := recover(); r != nil {
			logger.Error("goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-subCtx.Done():
			logger.Debug("stopping due to subscription context cancellation", "subs_uid", sub.id)
			return
		case <-ctx.Done():
			logger.Debug("stopping due to request context cancellation", "subs_uid", sub.id)
			return
		case event := <-sub.channels.applicationChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION, event.Object) {
				logger.Debug("Sending Application notification", "change_type", event.ChangeType, "uid", event.Object.Uid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION, event.ChangeType, event.Object.ToApplication()); err != nil {
					logger.Error("Error sending Application update", "err", err)
				}
			} else {
				logger.Debug("Skipping Application notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.applicationStateChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE, event.Object) {
				logger.Debug("Sending ApplicationState notification", "change_type", event.ChangeType, "uid", event.Object.Uid, "app_uid", event.Object.ApplicationUid, "app_status", event.Object.Status)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE, event.ChangeType, event.Object.ToApplicationState()); err != nil {
					logger.Error("Error sending ApplicationState update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationState notification for user", "user", sub.userName, "app_uid", event.Object.ApplicationUid, "app_status", event.Object.Status)
			}
		case event := <-sub.channels.applicationResourceChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE, event.Object) {
				logger.Debug("Sending ApplicationResource notification", "change_type", event.ChangeType, "uid", event.Object.Uid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE, event.ChangeType, event.Object.ToApplicationResource()); err != nil {
					logger.Error("Error sending ApplicationResource update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationResource notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.applicationTaskChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK, event.Object) {
				logger.Debug("Sending ApplicationTask notification", "change_type", event.ChangeType, "uid", event.Object.Uid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK, event.ChangeType, event.Object.ToApplicationTask()); err != nil {
					logger.Error("Error sending ApplicationTask update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationTask notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.roleChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE, event.Object) {
				logger.Debug("Sending Role notification", "change_type", event.ChangeType, "name", event.Object.Name)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE, event.ChangeType, event.Object.ToRole()); err != nil {
					logger.Error("Error sending Role update", "err", err)
				}
			} else {
				logger.Debug("Skipping Role notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.labelChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL, event.Object) {
				logger.Debug("Sending Label notification", "change_type", event.ChangeType, "uid", event.Object.Uid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL, event.ChangeType, event.Object.ToLabel()); err != nil {
					logger.Error("Error sending Label update", "err", err)
				}
			} else {
				logger.Debug("Skipping Label notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.nodeChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE, event.Object) {
				logger.Debug("Sending Node notification", "change_type", event.ChangeType, "uid", event.Object.Uid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE, event.ChangeType, event.Object.ToNode()); err != nil {
					logger.Error("Error sending Node update", "err", err)
				}
			} else {
				logger.Debug("Skipping Node notification for user", "user", sub.userName)
			}
		case event := <-sub.channels.userChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER, event.Object) {
				logger.Debug("Sending User notification", "change_type", event.ChangeType, "name", event.Object.Name)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER, event.ChangeType, event.Object.ToUser()); err != nil {
					logger.Error("Error sending User update", "err", err)
				}
			} else {
				logger.Debug("Skipping User notification for user", "user", sub.userName)
			}
		}
	}
}

// Close will close all the channels
func (s *subChannels) Close() {
	close(s.applicationChannel)
	close(s.applicationStateChannel)
	close(s.applicationResourceChannel)
	close(s.applicationTaskChannel)
	close(s.roleChannel)
	close(s.labelChannel)
	close(s.nodeChannel)
	close(s.userChannel)
}

// setupSubscriptions sets up database subscriptions and relay goroutines
func (s *StreamingService) setupSubscriptions(subCtx context.Context, subscriptionID string, sub *subscription, subscriptionTypes []aquariumv2.SubscriptionType) {
	logger := log.WithFunc("rpc", "setupSubscriptions").With("subs_uid", sub.id)
	for _, subType := range subscriptionTypes {
		switch subType {
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.ApplicationSubscriptionEvent, 100)
			s.fish.DB().SubscribeApplication(subCtx, dbChannel)
			logger.Debug("Subscribed to Application changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.ApplicationStateSubscriptionEvent, 100)
			s.fish.DB().SubscribeApplicationState(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationState changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationStateNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.ApplicationResourceSubscriptionEvent, 100)
			s.fish.DB().SubscribeApplicationResource(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationResource changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationResourceNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.ApplicationTaskSubscriptionEvent, 100)
			s.fish.DB().SubscribeApplicationTask(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationTask changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationTaskNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.RoleSubscriptionEvent, 100)
			s.fish.DB().SubscribeRole(subCtx, dbChannel)
			logger.Debug("Subscribed to Role changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayRoleNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.LabelSubscriptionEvent, 100)
			s.fish.DB().SubscribeLabel(subCtx, dbChannel)
			logger.Debug("Subscribed to Label changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayLabelNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.NodeSubscriptionEvent, 100)
			s.fish.DB().SubscribeNode(subCtx, dbChannel)
			logger.Debug("Subscribed to Node changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayNodeNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan database.UserSubscriptionEvent, 100)
			s.fish.DB().SubscribeUser(subCtx, dbChannel)
			logger.Debug("Subscribed to User changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayUserNotifications(subCtx, subscriptionID, sub, dbChannel)
		}
	}
}

// shouldSendObject checks if an object should be sent to the subscriber based on filters and permissions
func (s *StreamingService) shouldSendObject(sub *subscription, objectType aquariumv2.SubscriptionType, obj any) bool {
	// Check if this subscription type is requested
	found := false
	for _, subType := range sub.subscriptions {
		if subType == objectType {
			found = true
			break
		}
	}
	if !found {
		return false
	}

	// Apply filters based on object type
	switch objectType {
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION:
		if typedObj, ok := obj.(*typesv2.Application); ok {
			return s.shouldSendApplicationObject(sub, typedObj, auth.ApplicationServiceGet)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
		if typedObj, ok := obj.(*typesv2.ApplicationState); ok {
			return s.shouldSendApplicationStateObject(sub, typedObj, auth.ApplicationServiceGetState)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
		if typedObj, ok := obj.(*typesv2.ApplicationResource); ok {
			return s.shouldSendApplicationResourceObject(sub, typedObj, auth.ApplicationServiceGetResource)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
		if typedObj, ok := obj.(*typesv2.ApplicationTask); ok {
			return s.shouldSendApplicationTaskObject(sub, typedObj, auth.ApplicationServiceGetTask)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE:
		if typedObj, ok := obj.(*typesv2.Role); ok {
			return s.shouldSendRoleObject(sub, typedObj, auth.RoleServiceGet)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL:
		if typedObj, ok := obj.(*typesv2.Label); ok {
			return s.shouldSendLabelObject(sub, typedObj, auth.LabelServiceGet)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE:
		if typedObj, ok := obj.(*typesv2.Node); ok {
			return s.shouldSendNodeObject(sub, typedObj, auth.NodeServiceGet)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER:
		if typedObj, ok := obj.(*typesv2.User); ok {
			return s.shouldSendUserObject(sub, typedObj, auth.UserServiceGet)
		}
	}

	return true
}

// shouldSendApplication checks if application should be sent to subscriber
func (s *StreamingService) shouldSendApplication(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION {
			return true
		}
	}
	return false
}

// shouldSendApplicationState checks if applicationState should be sent to subscriber
func (s *StreamingService) shouldSendApplicationState(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE {
			return true
		}
	}
	return false
}

// shouldSendApplicationResource checks if applicationResource should be sent to subscriber
func (s *StreamingService) shouldSendApplicationResource(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE {
			return true
		}
	}
	return false
}

// shouldSendApplicationTask checks if applicationTask should be sent to subscriber
func (s *StreamingService) shouldSendApplicationTask(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK {
			return true
		}
	}
	return false
}

// shouldSendRole checks if role should be sent to subscriber
func (s *StreamingService) shouldSendRole(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE {
			return true
		}
	}
	return false
}

// shouldSendLabel checks if label should be sent to subscriber
func (s *StreamingService) shouldSendLabel(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL {
			return true
		}
	}
	return false
}

// shouldSendNode checks if node should be sent to subscriber
func (s *StreamingService) shouldSendNode(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE {
			return true
		}
	}
	return false
}

// shouldSendUser checks if user should be sent to subscriber
func (s *StreamingService) shouldSendUser(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER {
			return true
		}
	}
	return false
}

// getSubscriptionPermissionMethod returns the RBAC permission method for a subscription type
func (s *StreamingService) getSubscriptionPermissionMethod(subscriptionType aquariumv2.SubscriptionType) string {
	switch subscriptionType {
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION:
		return auth.ApplicationServiceGet
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
		return auth.ApplicationServiceGetState
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
		return auth.ApplicationServiceGetResource
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
		return auth.ApplicationServiceGetTask
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_ROLE:
		return auth.RoleServiceGet
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_LABEL:
		return auth.LabelServiceGet
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_NODE:
		return auth.NodeServiceGet
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_USER:
		return auth.UserServiceGet
	default:
		return ""
	}
}
