/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-streaming. DO NOT EDIT.

package rpc

// This file contains generated routing logic for streaming service
// It extends the main StreamingService with auto-generated request routing methods

import (
	"context"
	"fmt"
	"strings"
	"time"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/adobe/aquarium-fish/lib/auth"
	"github.com/adobe/aquarium-fish/lib/log"
	aquariumv2 "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
	rpcutil "github.com/adobe/aquarium-fish/lib/rpc/util"
	typesv2 "github.com/adobe/aquarium-fish/lib/types/aquarium/v2"
)

// subChannels is used to store channels for subscriptions communications
type subChannels struct {
	applicationStateChannel    chan *typesv2.ApplicationState
	applicationResourceChannel chan *typesv2.ApplicationResource
	applicationTaskChannel     chan *typesv2.ApplicationTask
}

// requestTypeMapping maps request types to service and method names for RBAC
type serviceMethodInfo struct {
	service string
	method  string
}

var requestTypeMapping = map[string]serviceMethodInfo{
	"ApplicationServiceCreateRequest":      {auth.ApplicationService, auth.ApplicationServiceCreate},
	"ApplicationServiceCreateTaskRequest":  {auth.ApplicationService, auth.ApplicationServiceCreateTask},
	"ApplicationServiceDeallocateRequest":  {auth.ApplicationService, auth.ApplicationServiceDeallocate},
	"ApplicationServiceGetRequest":         {auth.ApplicationService, auth.ApplicationServiceGet},
	"ApplicationServiceGetResourceRequest": {auth.ApplicationService, auth.ApplicationServiceGetResource},
	"ApplicationServiceGetStateRequest":    {auth.ApplicationService, auth.ApplicationServiceGetState},
	"ApplicationServiceGetTaskRequest":     {auth.ApplicationService, auth.ApplicationServiceGetTask},
	"ApplicationServiceListRequest":        {auth.ApplicationService, auth.ApplicationServiceList},
	"ApplicationServiceListTaskRequest":    {auth.ApplicationService, auth.ApplicationServiceListTask},
	"LabelServiceCreateRequest":            {auth.LabelService, auth.LabelServiceCreate},
	"LabelServiceDeleteRequest":            {auth.LabelService, auth.LabelServiceDelete},
	"LabelServiceGetRequest":               {auth.LabelService, auth.LabelServiceGet},
	"LabelServiceListRequest":              {auth.LabelService, auth.LabelServiceList},
	"NodeServiceGetThisRequest":            {auth.NodeService, auth.NodeServiceGetThis},
	"NodeServiceListRequest":               {auth.NodeService, auth.NodeServiceList},
	"NodeServiceSetMaintenanceRequest":     {auth.NodeService, auth.NodeServiceSetMaintenance},
	"RoleServiceCreateRequest":             {auth.RoleService, auth.RoleServiceCreate},
	"RoleServiceDeleteRequest":             {auth.RoleService, auth.RoleServiceDelete},
	"RoleServiceGetRequest":                {auth.RoleService, auth.RoleServiceGet},
	"RoleServiceListRequest":               {auth.RoleService, auth.RoleServiceList},
	"RoleServiceUpdateRequest":             {auth.RoleService, auth.RoleServiceUpdate},
	"UserServiceCreateRequest":             {auth.UserService, auth.UserServiceCreate},
	"UserServiceDeleteRequest":             {auth.UserService, auth.UserServiceDelete},
	"UserServiceGetRequest":                {auth.UserService, auth.UserServiceGet},
	"UserServiceGetMeRequest":              {auth.UserService, auth.UserServiceGetMe},
	"UserServiceListRequest":               {auth.UserService, auth.UserServiceList},
	"UserServiceUpdateRequest":             {auth.UserService, auth.UserServiceUpdate},
}

// routeApplicationServiceRequest routes applicationService service requests
func (s *StreamingService) routeApplicationServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "ApplicationServiceCreateRequest":
		var req aquariumv2.ApplicationServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}
		// Cache permission for the owner (creator) of the application
		if resp.Msg.Status && resp.Msg.Data != nil {
			userName := rpcutil.GetUserName(ctx)
			appUID := stringToUUID(resp.Msg.Data.Uid)
			s.permissionCache.GrantAccess(userName, appUID)
			logger := log.WithFunc("rpc", "routeApplicationServiceRequest")
			logger.Debug("Streaming: Cached permission for app creator", "user", userName, "app_uid", appUID)
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceCreateTaskRequest":
		var req aquariumv2.ApplicationServiceCreateTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.CreateTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceDeallocateRequest":
		var req aquariumv2.ApplicationServiceDeallocateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Deallocate(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetRequest":
		var req aquariumv2.ApplicationServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetResourceRequest":
		var req aquariumv2.ApplicationServiceGetResourceRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetResource(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetStateRequest":
		var req aquariumv2.ApplicationServiceGetStateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetState(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceGetTaskRequest":
		var req aquariumv2.ApplicationServiceGetTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.GetTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListRequest":
		var req aquariumv2.ApplicationServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "ApplicationServiceListTaskRequest":
		var req aquariumv2.ApplicationServiceListTaskRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.applicationService.ListTask(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported applicationService request type: %s", requestType))
	}
}

// routeLabelServiceRequest routes labelService service requests
func (s *StreamingService) routeLabelServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "LabelServiceCreateRequest":
		var req aquariumv2.LabelServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceDeleteRequest":
		var req aquariumv2.LabelServiceDeleteRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Delete(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceGetRequest":
		var req aquariumv2.LabelServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "LabelServiceListRequest":
		var req aquariumv2.LabelServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.labelService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported labelService request type: %s", requestType))
	}
}

// routeNodeServiceRequest routes nodeService service requests
func (s *StreamingService) routeNodeServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "NodeServiceGetThisRequest":
		var req aquariumv2.NodeServiceGetThisRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.GetThis(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "NodeServiceListRequest":
		var req aquariumv2.NodeServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "NodeServiceSetMaintenanceRequest":
		var req aquariumv2.NodeServiceSetMaintenanceRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.nodeService.SetMaintenance(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported nodeService request type: %s", requestType))
	}
}

// routeRoleServiceRequest routes roleService service requests
func (s *StreamingService) routeRoleServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "RoleServiceCreateRequest":
		var req aquariumv2.RoleServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceDeleteRequest":
		var req aquariumv2.RoleServiceDeleteRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Delete(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceGetRequest":
		var req aquariumv2.RoleServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceListRequest":
		var req aquariumv2.RoleServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "RoleServiceUpdateRequest":
		var req aquariumv2.RoleServiceUpdateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.roleService.Update(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported roleService request type: %s", requestType))
	}
}

// routeUserServiceRequest routes userService service requests
func (s *StreamingService) routeUserServiceRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	switch requestType {
	case "UserServiceCreateRequest":
		var req aquariumv2.UserServiceCreateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Create(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceDeleteRequest":
		var req aquariumv2.UserServiceDeleteRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Delete(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceGetRequest":
		var req aquariumv2.UserServiceGetRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Get(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceGetMeRequest":
		var req aquariumv2.UserServiceGetMeRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.GetMe(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceListRequest":
		var req aquariumv2.UserServiceListRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.List(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	case "UserServiceUpdateRequest":
		var req aquariumv2.UserServiceUpdateRequest
		if err := requestData.UnmarshalTo(&req); err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, err)
		}
		resp, err := s.userService.Update(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		return anypb.New(resp.Msg)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported userService request type: %s", requestType))
	}
}

// routeRequest routes a request to the appropriate service handler
func (s *StreamingService) routeRequest(ctx context.Context, requestType string, requestData *anypb.Any) (*anypb.Any, error) {
	logger := log.WithFunc("rpc", "routeRequest")
	logger.Debug("Streaming: Routing request type", "req_type", requestType)

	// Route to the appropriate service using generated routing methods
	switch {
	case strings.HasPrefix(requestType, "ApplicationService"):
		return s.routeApplicationServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "LabelService"):
		return s.routeLabelServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "NodeService"):
		return s.routeNodeServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "RoleService"):
		return s.routeRoleServiceRequest(ctx, requestType, requestData)
	case strings.HasPrefix(requestType, "UserService"):
		return s.routeUserServiceRequest(ctx, requestType, requestData)
	default:
		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("unsupported request type: %s", requestType))
	}
}

// Subscription-related helper methods
// relayApplicationStateNotifications safely relays applicationState notifications with buffer overflow protection
func (s *StreamingService) relayApplicationStateNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel <-chan *typesv2.ApplicationState) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationStateNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationState relay goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationState relay stopping due to context cancellation")
			return
		case obj, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationState relay stopping due to closed database channel")
				return
			}

			// Check if client is already overflowing - skip notification to prevent further overflow
			if sub.isClientOverflowing() {
				logger.Debug("Skipping applicationState notification due to client overflow")
				continue
			}

			// Try to send safely - if this returns true, client should be disconnected
			if shouldDisconnect := !sub.safeSendToApplicationStateChannel(obj); shouldDisconnect {
				logger.Error("Disconnecting client due to excessive buffer overflow")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayApplicationResourceNotifications safely relays applicationResource notifications with buffer overflow protection
func (s *StreamingService) relayApplicationResourceNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel <-chan *typesv2.ApplicationResource) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationResourceNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationResource relay goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationResource relay stopping due to context cancellation")
			return
		case obj, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationResource relay stopping due to closed database channel")
				return
			}

			// Check if client is already overflowing - skip notification to prevent further overflow
			if sub.isClientOverflowing() {
				logger.Debug("Skipping applicationResource notification due to client overflow")
				continue
			}

			// Try to send safely - if this returns true, client should be disconnected
			if shouldDisconnect := !sub.safeSendToApplicationResourceChannel(obj); shouldDisconnect {
				logger.Error("Disconnecting client due to excessive buffer overflow")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// relayApplicationTaskNotifications safely relays applicationTask notifications with buffer overflow protection
func (s *StreamingService) relayApplicationTaskNotifications(ctx context.Context, subscriptionID string, sub *subscription, dbChannel <-chan *typesv2.ApplicationTask) {
	// Signal completion when this goroutine exits
	defer sub.relayWg.Done()
	logger := log.WithFunc("rpc", "relayApplicationTaskNotifications").With("subs_uid", subscriptionID)

	defer func() {
		if r := recover(); r != nil {
			logger.Error("ApplicationTask relay goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-ctx.Done():
			logger.Debug("ApplicationTask relay stopping due to context cancellation")
			return
		case obj, ok := <-dbChannel:
			if !ok {
				logger.Debug("ApplicationTask relay stopping due to closed database channel")
				return
			}

			// Check if client is already overflowing - skip notification to prevent further overflow
			if sub.isClientOverflowing() {
				logger.Debug("Skipping applicationTask notification due to client overflow")
				continue
			}

			// Try to send safely - if this returns true, client should be disconnected
			if shouldDisconnect := !sub.safeSendToApplicationTaskChannel(obj); shouldDisconnect {
				logger.Error("Disconnecting client due to excessive buffer overflow")
				sub.cancel() // This will cause the main subscription loop to exit
				return
			}
		}
	}
}

// setupChannels sets the channels for the database changes
func (s *StreamingService) setupChannels() *subChannels {
	return &subChannels{
		applicationStateChannel:    make(chan *typesv2.ApplicationState, 100),
		applicationResourceChannel: make(chan *typesv2.ApplicationResource, 100),
		applicationTaskChannel:     make(chan *typesv2.ApplicationTask, 100),
	}
}

// listenChannels listen for database channels
func (s *StreamingService) listenChannels(sub *subscription, ctx, subCtx context.Context) {
	logger := log.WithFunc("rpc", "listenChannels").With("subs_uid", sub.id)
	// Signal completion when this goroutine exits
	defer sub.listenChannelsWg.Done()

	defer func() {
		if r := recover(); r != nil {
			logger.Error("goroutine panic", "panic", r)
		}
	}()

	for {
		select {
		case <-subCtx.Done():
			logger.Debug("stopping due to subscription context cancellation", "subs_uid", sub.id)
			return
		case <-ctx.Done():
			logger.Debug("stopping due to request context cancellation", "subs_uid", sub.id)
			return
		case msg := <-sub.channels.applicationStateChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE, msg) {
				logger.Debug("Sending ApplicationState notification for Application UID", "app_uid", msg.ApplicationUid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE, aquariumv2.ChangeType_CHANGE_TYPE_CREATED, msg.ToApplicationState()); err != nil {
					logger.Error("Error sending ApplicationState update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationState notification for user", "user", sub.userName)
			}
		case msg := <-sub.channels.applicationResourceChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE, msg) {
				logger.Debug("Sending ApplicationResource notification for Application UID", "app_uid", msg.ApplicationUid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE, aquariumv2.ChangeType_CHANGE_TYPE_CREATED, msg.ToApplicationResource()); err != nil {
					logger.Error("Error sending ApplicationResource update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationResource notification for user", "user", sub.userName)
			}
		case msg := <-sub.channels.applicationTaskChannel:
			if s.shouldSendObject(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK, msg) {
				logger.Debug("Sending ApplicationTask notification for Application UID", "app_uid", msg.ApplicationUid)
				if err := s.sendSubscriptionResponse(sub, aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK, aquariumv2.ChangeType_CHANGE_TYPE_CREATED, msg.ToApplicationTask()); err != nil {
					logger.Error("Error sending ApplicationTask update", "err", err)
				}
			} else {
				logger.Debug("Skipping ApplicationTask notification for user", "user", sub.userName)
			}
		}
	}
}

// Close will close all the channels
func (s *subChannels) Close() {
	close(s.applicationStateChannel)
	close(s.applicationResourceChannel)
	close(s.applicationTaskChannel)
}

// setupSubscriptions sets up database subscriptions and relay goroutines
func (s *StreamingService) setupSubscriptions(subCtx context.Context, subscriptionID string, sub *subscription, subscriptionTypes []aquariumv2.SubscriptionType) {
	logger := log.WithFunc("rpc", "setupSubscriptions").With("subs_uid", sub.id)
	for _, subType := range subscriptionTypes {
		switch subType {
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan *typesv2.ApplicationState, 100)
			s.fish.DB().SubscribeApplicationState(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationState changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationStateNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan *typesv2.ApplicationResource, 100)
			s.fish.DB().SubscribeApplicationResource(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationResource changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationResourceNotifications(subCtx, subscriptionID, sub, dbChannel)
		case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
			// Create a safe wrapper channel for database notifications
			dbChannel := make(chan *typesv2.ApplicationTask, 100)
			s.fish.DB().SubscribeApplicationTask(subCtx, dbChannel)
			logger.Debug("Subscribed to ApplicationTask changes")

			// Add to WaitGroup before starting goroutine
			sub.relayWg.Add(1)
			// Start goroutine to safely relay notifications to subscription
			go s.relayApplicationTaskNotifications(subCtx, subscriptionID, sub, dbChannel)
		}
	}
}

// shouldSendObject checks if an object should be sent to the subscriber based on filters and permissions
func (s *StreamingService) shouldSendObject(sub *subscription, objectType aquariumv2.SubscriptionType, obj any) bool {
	// Check if this subscription type is requested
	found := false
	for _, subType := range sub.subscriptions {
		if subType == objectType {
			found = true
			break
		}
	}
	if !found {
		return false
	}

	// Apply filters based on object type
	switch objectType {
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
		if typedObj, ok := obj.(*typesv2.ApplicationState); ok {
			return s.shouldSendApplicationObject(sub, typedObj.ApplicationUid, objectType)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
		if typedObj, ok := obj.(*typesv2.ApplicationResource); ok {
			return s.shouldSendApplicationObject(sub, typedObj.ApplicationUid, objectType)
		}
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
		if typedObj, ok := obj.(*typesv2.ApplicationTask); ok {
			return s.shouldSendApplicationObject(sub, typedObj.ApplicationUid, objectType)
		}
	}

	return true
}

// shouldSendApplicationState checks if applicationState should be sent to subscriber
func (s *StreamingService) shouldSendApplicationState(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE {
			return true
		}
	}
	return false
}

// shouldSendApplicationResource checks if applicationResource should be sent to subscriber
func (s *StreamingService) shouldSendApplicationResource(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE {
			return true
		}
	}
	return false
}

// shouldSendApplicationTask checks if applicationTask should be sent to subscriber
func (s *StreamingService) shouldSendApplicationTask(sub *subscription) bool {
	for _, subType := range sub.subscriptions {
		if subType == aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK {
			return true
		}
	}
	return false
}

// safeSendToApplicationStateChannel attempts to send to state channel with overflow detection
func (sub *subscription) safeSendToApplicationStateChannel(msg *typesv2.ApplicationState) bool {
	logger := log.WithFunc("rpc", "safeSendToApplicationStateChannel").With("subs_uid", sub.id, "sub_user", sub.userName)
	select {
	case sub.channels.applicationStateChannel <- msg:
		sub.resetOverflow()
		return true
	case <-time.After(overflowTimeout):
		logger.Warn("ApplicationState channel send timeout (buffer overflow)")
		return sub.recordOverflow()
	default:
		logger.Warn("ApplicationState channel full (buffer overflow)")
		return sub.recordOverflow()
	}
}

// safeSendToApplicationResourceChannel attempts to send to state channel with overflow detection
func (sub *subscription) safeSendToApplicationResourceChannel(msg *typesv2.ApplicationResource) bool {
	logger := log.WithFunc("rpc", "safeSendToApplicationResourceChannel").With("subs_uid", sub.id, "sub_user", sub.userName)
	select {
	case sub.channels.applicationResourceChannel <- msg:
		sub.resetOverflow()
		return true
	case <-time.After(overflowTimeout):
		logger.Warn("ApplicationResource channel send timeout (buffer overflow)")
		return sub.recordOverflow()
	default:
		logger.Warn("ApplicationResource channel full (buffer overflow)")
		return sub.recordOverflow()
	}
}

// safeSendToApplicationTaskChannel attempts to send to state channel with overflow detection
func (sub *subscription) safeSendToApplicationTaskChannel(msg *typesv2.ApplicationTask) bool {
	logger := log.WithFunc("rpc", "safeSendToApplicationTaskChannel").With("subs_uid", sub.id, "sub_user", sub.userName)
	select {
	case sub.channels.applicationTaskChannel <- msg:
		sub.resetOverflow()
		return true
	case <-time.After(overflowTimeout):
		logger.Warn("ApplicationTask channel send timeout (buffer overflow)")
		return sub.recordOverflow()
	default:
		logger.Warn("ApplicationTask channel full (buffer overflow)")
		return sub.recordOverflow()
	}
}

// getSubscriptionPermissionMethod returns the RBAC permission method for a subscription type
func (s *StreamingService) getSubscriptionPermissionMethod(subscriptionType aquariumv2.SubscriptionType) string {
	switch subscriptionType {
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_STATE:
		return auth.ApplicationServiceGetStateAll
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_RESOURCE:
		return auth.ApplicationServiceGetResourceAll
	case aquariumv2.SubscriptionType_SUBSCRIPTION_TYPE_APPLICATION_TASK:
		return auth.ApplicationServiceListTaskAll
	default:
		return ""
	}
}
