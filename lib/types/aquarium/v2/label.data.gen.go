/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package aquariumv2

import (
	"encoding/json"

	"time"

	"github.com/google/uuid"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/structpb"

	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/adobe/aquarium-fish/lib/util"

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

type LabelUID = uuid.UUID

// Label is a data for Label without internal locks
type Label struct {
	CreatedAt   time.Time         `json:"created_at,omitempty"`
	Definitions []LabelDefinition `json:"definitions,omitempty"`
	Metadata    util.UnparsedJSON `json:"metadata,omitempty"`
	Name        string            `json:"name,omitempty"`
	Uid         uuid.UUID         `json:"uid,omitempty"`
	Version     int32             `json:"version,omitempty"`
}

// FromLabel creates a Label from Label
func FromLabel(src *pbTypes.Label) Label {
	if src == nil {
		return Label{}
	}

	result := Label{}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	for _, item := range src.GetDefinitions() {
		if item != nil {
			result.Definitions = append(result.Definitions, FromLabelDefinition(item))
		}
	}
	if src.GetMetadata() != nil {
		if data, err := protojson.Marshal(src.GetMetadata()); err == nil {
			result.Metadata = util.UnparsedJSON(data)
		}
	} else {
		result.Metadata = util.UnparsedJSON("{}")
	}
	result.Name = src.GetName()
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	result.Version = src.GetVersion()
	return result
}

// ToLabel converts Label to Label
func (l Label) ToLabel() *pbTypes.Label {
	result := &pbTypes.Label{}

	result.CreatedAt = timestamppb.New(l.CreatedAt)
	for _, item := range l.Definitions {
		result.Definitions = append(result.Definitions, item.ToLabelDefinition())
	}
	var mapData map[string]any
	mapData = make(map[string]any)
	if err := json.Unmarshal([]byte(l.Metadata), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Metadata = structData
		}
	}
	result.Name = l.Name
	result.Uid = l.Uid.String()
	result.Version = l.Version
	return result
}

// LabelDefinition is a data for LabelDefinition without internal locks
type LabelDefinition struct {
	Authentication *Authentication   `json:"authentication,omitempty"`
	Driver         string            `json:"driver,omitempty"`
	Options        util.UnparsedJSON `json:"options,omitempty"`
	Resources      Resources         `json:"resources,omitempty"`
}

// FromLabelDefinition creates a LabelDefinition from LabelDefinition
func FromLabelDefinition(src *pbTypes.LabelDefinition) LabelDefinition {
	if src == nil {
		return LabelDefinition{}
	}

	result := LabelDefinition{}
	if src.GetAuthentication() != nil {
		data := FromAuthentication(src.GetAuthentication())
		result.Authentication = &data
	}
	result.Driver = src.GetDriver()
	if src.GetOptions() != nil {
		if data, err := protojson.Marshal(src.GetOptions()); err == nil {
			result.Options = util.UnparsedJSON(data)
		}
	} else {
		result.Options = util.UnparsedJSON("{}")
	}
	if src.GetResources() != nil {
		result.Resources = FromResources(src.GetResources())
	}
	return result
}

// ToLabelDefinition converts LabelDefinition to LabelDefinition
func (l LabelDefinition) ToLabelDefinition() *pbTypes.LabelDefinition {
	result := &pbTypes.LabelDefinition{}

	if l.Authentication != nil {
		result.Authentication = l.Authentication.ToAuthentication()
	}
	result.Driver = l.Driver
	var mapData map[string]any
	mapData = make(map[string]any)
	if err := json.Unmarshal([]byte(l.Options), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Options = structData
		}
	}
	result.Resources = l.Resources.ToResources()
	return result
}

// Resources is a data for Resources without internal locks
type Resources struct {
	Cpu          uint32                   `json:"cpu,omitempty"`
	CpuOverbook  bool                     `json:"cpu_overbook,omitempty"`
	Disks        map[string]ResourcesDisk `json:"disks,omitempty"`
	Lifetime     string                   `json:"lifetime,omitempty"`
	Multitenancy bool                     `json:"multitenancy,omitempty"`
	Network      string                   `json:"network,omitempty"`
	NodeFilter   []string                 `json:"node_filter,omitempty"`
	Ram          uint32                   `json:"ram,omitempty"`
	RamOverbook  bool                     `json:"ram_overbook,omitempty"`
	Slots        *uint32                  `json:"slots,omitempty"`
}

// FromResources creates a Resources from Resources
func FromResources(src *pbTypes.Resources) Resources {
	if src == nil {
		return Resources{}
	}

	result := Resources{}
	result.Cpu = src.GetCpu()
	result.CpuOverbook = src.GetCpuOverbook()
	// Convert map field disks
	if src.GetDisks() != nil {
		result.Disks = make(map[string]ResourcesDisk)
		for k, v := range src.GetDisks() {
			if v != nil {
				result.Disks[k] = FromResourcesDisk(v)
			}
		}
	}
	result.Lifetime = src.GetLifetime()
	result.Multitenancy = src.GetMultitenancy()
	result.Network = src.GetNetwork()
	result.NodeFilter = src.GetNodeFilter()
	result.Ram = src.GetRam()
	result.RamOverbook = src.GetRamOverbook()
	if src.GetSlots() != 0 {
		val := src.GetSlots()
		result.Slots = &val
	}
	return result
}

// ToResources converts Resources to Resources
func (r Resources) ToResources() *pbTypes.Resources {
	result := &pbTypes.Resources{}

	result.Cpu = r.Cpu
	result.CpuOverbook = r.CpuOverbook
	// Convert map field disks
	if r.Disks != nil {
		result.Disks = make(map[string]*pbTypes.ResourcesDisk)
		for k, v := range r.Disks {
			result.Disks[k] = v.ToResourcesDisk()
		}
	}
	result.Lifetime = r.Lifetime
	result.Multitenancy = r.Multitenancy
	result.Network = r.Network
	result.NodeFilter = r.NodeFilter
	result.Ram = r.Ram
	result.RamOverbook = r.RamOverbook
	if r.Slots != nil {
		result.Slots = r.Slots
	}
	return result
}

// ResourcesDisk is a data for ResourcesDisk without internal locks
type ResourcesDisk struct {
	Clone string `json:"clone,omitempty"`
	Label string `json:"label,omitempty"`
	Reuse bool   `json:"reuse,omitempty"`
	Size  uint32 `json:"size,omitempty"`
	Type  string `json:"type,omitempty"`
}

// FromResourcesDisk creates a ResourcesDisk from ResourcesDisk
func FromResourcesDisk(src *pbTypes.ResourcesDisk) ResourcesDisk {
	if src == nil {
		return ResourcesDisk{}
	}

	result := ResourcesDisk{}
	result.Clone = src.GetClone()
	result.Label = src.GetLabel()
	result.Reuse = src.GetReuse()
	result.Size = src.GetSize()
	result.Type = src.GetType()
	return result
}

// ToResourcesDisk converts ResourcesDisk to ResourcesDisk
func (r ResourcesDisk) ToResourcesDisk() *pbTypes.ResourcesDisk {
	result := &pbTypes.ResourcesDisk{}

	result.Clone = r.Clone
	result.Label = r.Label
	result.Reuse = r.Reuse
	result.Size = r.Size
	result.Type = r.Type
	return result
}
