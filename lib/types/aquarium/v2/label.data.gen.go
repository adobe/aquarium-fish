/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package aquariumv2

import (
	"encoding/json"

	"time"

	"github.com/google/uuid"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/structpb"

	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/adobe/aquarium-fish/lib/util"

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

type LabelUID = uuid.UUID

// Image is a data for Image without internal locks
type Image struct {
	Name    *string `json:"name,omitempty"`
	Sum     *string `json:"sum,omitempty"`
	Tag     *string `json:"tag,omitempty"`
	Url     *string `json:"url,omitempty"`
	Version *string `json:"version,omitempty"`
}

// FromImage creates a Image from Image
func FromImage(src *pbTypes.Image) Image {
	if src == nil {
		return Image{}
	}

	result := Image{}
	if src.Name != nil {
		val := src.GetName()
		result.Name = &val
	}
	if src.Sum != nil {
		val := src.GetSum()
		result.Sum = &val
	}
	if src.Tag != nil {
		val := src.GetTag()
		result.Tag = &val
	}
	if src.Url != nil {
		val := src.GetUrl()
		result.Url = &val
	}
	if src.Version != nil {
		val := src.GetVersion()
		result.Version = &val
	}
	return result
}

// ToImage converts Image to Image
func (i Image) ToImage() *pbTypes.Image {
	result := &pbTypes.Image{}

	if i.Name != nil {
		result.Name = i.Name
	}
	if i.Sum != nil {
		result.Sum = i.Sum
	}
	if i.Tag != nil {
		result.Tag = i.Tag
	}
	if i.Url != nil {
		result.Url = i.Url
	}
	if i.Version != nil {
		result.Version = i.Version
	}
	return result
}

// Label is a data for Label without internal locks
type Label struct {
	CreatedAt   time.Time         `json:"created_at,omitempty"`
	Definitions []LabelDefinition `json:"definitions,omitempty"`
	Metadata    util.UnparsedJSON `json:"metadata,omitempty"`
	Name        string            `json:"name,omitempty"`
	OwnerName   string            `json:"owner_name,omitempty"`
	RemoveAt    *time.Time        `json:"remove_at,omitempty"`
	Uid         uuid.UUID         `json:"uid,omitempty"`
	UpdatedAt   time.Time         `json:"updated_at,omitempty"`
	Version     int32             `json:"version,omitempty"`
	VisibleFor  []string          `json:"visible_for,omitempty"`
}

// FromLabel creates a Label from Label
func FromLabel(src *pbTypes.Label) Label {
	if src == nil {
		return Label{}
	}

	result := Label{}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	for _, item := range src.GetDefinitions() {
		if item != nil {
			result.Definitions = append(result.Definitions, FromLabelDefinition(item))
		}
	}
	if src.GetMetadata() != nil {
		if data, err := protojson.Marshal(src.GetMetadata()); err == nil {
			result.Metadata = util.UnparsedJSON(data)
		}
	} else {
		result.Metadata = util.UnparsedJSON("{}")
	}
	result.Name = src.GetName()
	result.OwnerName = src.GetOwnerName()
	if src.GetRemoveAt() != nil {
		t := src.GetRemoveAt().AsTime()
		result.RemoveAt = &t
	}
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	if src.GetUpdatedAt() != nil {
		result.UpdatedAt = src.GetUpdatedAt().AsTime()
	}
	result.Version = src.GetVersion()
	result.VisibleFor = src.GetVisibleFor()
	return result
}

// ToLabel converts Label to Label
func (l Label) ToLabel() *pbTypes.Label {
	result := &pbTypes.Label{}

	result.CreatedAt = timestamppb.New(l.CreatedAt)
	for _, item := range l.Definitions {
		result.Definitions = append(result.Definitions, item.ToLabelDefinition())
	}
	var mapData map[string]any
	mapData = make(map[string]any)
	if err := json.Unmarshal([]byte(l.Metadata), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Metadata = structData
		}
	}
	result.Name = l.Name
	result.OwnerName = l.OwnerName
	if l.RemoveAt != nil {
		result.RemoveAt = timestamppb.New(*l.RemoveAt)
	}
	result.Uid = l.Uid.String()
	result.UpdatedAt = timestamppb.New(l.UpdatedAt)
	result.Version = l.Version
	result.VisibleFor = l.VisibleFor
	return result
}

// LabelDefinition is a data for LabelDefinition without internal locks
type LabelDefinition struct {
	Authentication *Authentication   `json:"authentication,omitempty"`
	Driver         string            `json:"driver,omitempty"`
	Images         []Image           `json:"images,omitempty"`
	Options        util.UnparsedJSON `json:"options,omitempty"`
	Resources      Resources         `json:"resources,omitempty"`
}

// FromLabelDefinition creates a LabelDefinition from LabelDefinition
func FromLabelDefinition(src *pbTypes.LabelDefinition) LabelDefinition {
	if src == nil {
		return LabelDefinition{}
	}

	result := LabelDefinition{}
	if src.GetAuthentication() != nil {
		data := FromAuthentication(src.GetAuthentication())
		result.Authentication = &data
	}
	result.Driver = src.GetDriver()
	for _, item := range src.GetImages() {
		if item != nil {
			result.Images = append(result.Images, FromImage(item))
		}
	}
	if src.GetOptions() != nil {
		if data, err := protojson.Marshal(src.GetOptions()); err == nil {
			result.Options = util.UnparsedJSON(data)
		}
	} else {
		result.Options = util.UnparsedJSON("{}")
	}
	if src.GetResources() != nil {
		result.Resources = FromResources(src.GetResources())
	}
	return result
}

// ToLabelDefinition converts LabelDefinition to LabelDefinition
func (l LabelDefinition) ToLabelDefinition() *pbTypes.LabelDefinition {
	result := &pbTypes.LabelDefinition{}

	if l.Authentication != nil {
		result.Authentication = l.Authentication.ToAuthentication()
	}
	result.Driver = l.Driver
	for _, item := range l.Images {
		result.Images = append(result.Images, item.ToImage())
	}
	var mapData map[string]any
	mapData = make(map[string]any)
	if err := json.Unmarshal([]byte(l.Options), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Options = structData
		}
	}
	result.Resources = l.Resources.ToResources()
	return result
}

// Resources is a data for Resources without internal locks
type Resources struct {
	Cpu          uint32                   `json:"cpu,omitempty"`
	CpuOverbook  *bool                    `json:"cpu_overbook,omitempty"`
	Disks        map[string]ResourcesDisk `json:"disks,omitempty"`
	Lifetime     *string                  `json:"lifetime,omitempty"`
	Multitenancy *bool                    `json:"multitenancy,omitempty"`
	Network      *string                  `json:"network,omitempty"`
	NodeFilter   []string                 `json:"node_filter,omitempty"`
	Ram          uint32                   `json:"ram,omitempty"`
	RamOverbook  *bool                    `json:"ram_overbook,omitempty"`
	Slots        *uint32                  `json:"slots,omitempty"`
}

// FromResources creates a Resources from Resources
func FromResources(src *pbTypes.Resources) Resources {
	if src == nil {
		return Resources{}
	}

	result := Resources{}
	result.Cpu = src.GetCpu()
	if src.CpuOverbook != nil {
		val := src.GetCpuOverbook()
		result.CpuOverbook = &val
	}
	// Convert map field disks
	if src.GetDisks() != nil {
		result.Disks = make(map[string]ResourcesDisk)
		for k, v := range src.GetDisks() {
			if v != nil {
				result.Disks[k] = FromResourcesDisk(v)
			}
		}
	}
	if src.Lifetime != nil {
		val := src.GetLifetime()
		result.Lifetime = &val
	}
	if src.Multitenancy != nil {
		val := src.GetMultitenancy()
		result.Multitenancy = &val
	}
	if src.Network != nil {
		val := src.GetNetwork()
		result.Network = &val
	}
	result.NodeFilter = src.GetNodeFilter()
	result.Ram = src.GetRam()
	if src.RamOverbook != nil {
		val := src.GetRamOverbook()
		result.RamOverbook = &val
	}
	if src.Slots != nil {
		val := src.GetSlots()
		result.Slots = &val
	}
	return result
}

// ToResources converts Resources to Resources
func (r Resources) ToResources() *pbTypes.Resources {
	result := &pbTypes.Resources{}

	result.Cpu = r.Cpu
	if r.CpuOverbook != nil {
		result.CpuOverbook = r.CpuOverbook
	}
	// Convert map field disks
	if r.Disks != nil {
		result.Disks = make(map[string]*pbTypes.ResourcesDisk)
		for k, v := range r.Disks {
			result.Disks[k] = v.ToResourcesDisk()
		}
	}
	if r.Lifetime != nil {
		result.Lifetime = r.Lifetime
	}
	if r.Multitenancy != nil {
		result.Multitenancy = r.Multitenancy
	}
	if r.Network != nil {
		result.Network = r.Network
	}
	result.NodeFilter = r.NodeFilter
	result.Ram = r.Ram
	if r.RamOverbook != nil {
		result.RamOverbook = r.RamOverbook
	}
	if r.Slots != nil {
		result.Slots = r.Slots
	}
	return result
}

// ResourcesDisk is a data for ResourcesDisk without internal locks
type ResourcesDisk struct {
	Clone *string `json:"clone,omitempty"`
	Label *string `json:"label,omitempty"`
	Reuse *bool   `json:"reuse,omitempty"`
	Size  *uint32 `json:"size,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// FromResourcesDisk creates a ResourcesDisk from ResourcesDisk
func FromResourcesDisk(src *pbTypes.ResourcesDisk) ResourcesDisk {
	if src == nil {
		return ResourcesDisk{}
	}

	result := ResourcesDisk{}
	if src.Clone != nil {
		val := src.GetClone()
		result.Clone = &val
	}
	if src.Label != nil {
		val := src.GetLabel()
		result.Label = &val
	}
	if src.Reuse != nil {
		val := src.GetReuse()
		result.Reuse = &val
	}
	if src.Size != nil {
		val := src.GetSize()
		result.Size = &val
	}
	if src.Type != nil {
		val := src.GetType()
		result.Type = &val
	}
	return result
}

// ToResourcesDisk converts ResourcesDisk to ResourcesDisk
func (r ResourcesDisk) ToResourcesDisk() *pbTypes.ResourcesDisk {
	result := &pbTypes.ResourcesDisk{}

	if r.Clone != nil {
		result.Clone = r.Clone
	}
	if r.Label != nil {
		result.Label = r.Label
	}
	if r.Reuse != nil {
		result.Reuse = r.Reuse
	}
	if r.Size != nil {
		result.Size = r.Size
	}
	if r.Type != nil {
		result.Type = r.Type
	}
	return result
}
