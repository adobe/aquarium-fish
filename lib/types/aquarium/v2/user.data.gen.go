/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package aquariumv2

import (
	"encoding/json"

	"time"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/structpb"

	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/adobe/aquarium-fish/lib/util"

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

// User is a data for User without internal locks
type User struct {
	Config    *UserConfig        `json:"config,omitempty"`
	CreatedAt time.Time          `json:"created_at,omitempty"`
	Hash      *util.UnparsedJSON `json:"hash,omitempty"`
	Name      string             `json:"name,omitempty"`
	Password  *string            `json:"password,omitempty"`
	Roles     []string           `json:"roles,omitempty"`
	UpdatedAt time.Time          `json:"updated_at,omitempty"`
}

// FromUser creates a User from User
func FromUser(src *pbTypes.User) User {
	if src == nil {
		return User{}
	}

	result := User{}
	if src.GetConfig() != nil {
		data := FromUserConfig(src.GetConfig())
		result.Config = &data
	}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	if src.GetHash() != nil {
		if data, err := protojson.Marshal(src.GetHash()); err == nil {
			json := util.UnparsedJSON(data)
			result.Hash = &json
		}
	}
	result.Name = src.GetName()
	if src.Password != nil {
		val := src.GetPassword()
		result.Password = &val
	}
	result.Roles = src.GetRoles()
	if src.GetUpdatedAt() != nil {
		result.UpdatedAt = src.GetUpdatedAt().AsTime()
	}
	return result
}

// ToUser converts User to User
func (u User) ToUser() *pbTypes.User {
	result := &pbTypes.User{}

	if u.Config != nil {
		result.Config = u.Config.ToUserConfig()
	}
	result.CreatedAt = timestamppb.New(u.CreatedAt)
	if u.Hash != nil {
		var mapData map[string]any
		mapData = make(map[string]any)
		if err := json.Unmarshal([]byte(*u.Hash), &mapData); err == nil {
			if structData, err := structpb.NewStruct(mapData); err == nil {
				result.Hash = structData
			}
		}
	}
	result.Name = u.Name
	if u.Password != nil {
		result.Password = u.Password
	}
	result.Roles = u.Roles
	result.UpdatedAt = timestamppb.New(u.UpdatedAt)
	return result
}

// UserConfig is a data for UserConfig without internal locks
type UserConfig struct {
	RateLimit    *int32 `json:"rate_limit,omitempty"`
	StreamsLimit *int32 `json:"streams_limit,omitempty"`
}

// FromUserConfig creates a UserConfig from UserConfig
func FromUserConfig(src *pbTypes.UserConfig) UserConfig {
	if src == nil {
		return UserConfig{}
	}

	result := UserConfig{}
	if src.RateLimit != nil {
		val := src.GetRateLimit()
		result.RateLimit = &val
	}
	if src.StreamsLimit != nil {
		val := src.GetStreamsLimit()
		result.StreamsLimit = &val
	}
	return result
}

// ToUserConfig converts UserConfig to UserConfig
func (u UserConfig) ToUserConfig() *pbTypes.UserConfig {
	result := &pbTypes.UserConfig{}

	if u.RateLimit != nil {
		result.RateLimit = u.RateLimit
	}
	if u.StreamsLimit != nil {
		result.StreamsLimit = u.StreamsLimit
	}
	return result
}
