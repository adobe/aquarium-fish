/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package aquariumv2

import (
	"time"

	"github.com/google/uuid"

	"google.golang.org/protobuf/types/known/timestamppb"

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

type NodeUID = uuid.UUID

// CpuInfo is a data for CpuInfo without internal locks
type CpuInfo struct {
	CacheSize  string  `json:"cache_size,omitempty"`
	CoreId     string  `json:"core_id,omitempty"`
	Cores      int32   `json:"cores,omitempty"`
	Cpu        string  `json:"cpu,omitempty"`
	Family     string  `json:"family,omitempty"`
	Mhz        float32 `json:"mhz,omitempty"`
	Microcode  string  `json:"microcode,omitempty"`
	Model      string  `json:"model,omitempty"`
	ModelName  string  `json:"model_name,omitempty"`
	PhysicalId string  `json:"physical_id,omitempty"`
	Stepping   string  `json:"stepping,omitempty"`
	VendorId   string  `json:"vendor_id,omitempty"`
}

// FromCpuInfo creates a CpuInfo from CpuInfo
func FromCpuInfo(src *pbTypes.CpuInfo) CpuInfo {
	if src == nil {
		return CpuInfo{}
	}

	result := CpuInfo{}
	result.CacheSize = src.GetCacheSize()
	result.CoreId = src.GetCoreId()
	result.Cores = src.GetCores()
	result.Cpu = src.GetCpu()
	result.Family = src.GetFamily()
	result.Mhz = src.GetMhz()
	result.Microcode = src.GetMicrocode()
	result.Model = src.GetModel()
	result.ModelName = src.GetModelName()
	result.PhysicalId = src.GetPhysicalId()
	result.Stepping = src.GetStepping()
	result.VendorId = src.GetVendorId()
	return result
}

// ToCpuInfo converts CpuInfo to CpuInfo
func (c CpuInfo) ToCpuInfo() *pbTypes.CpuInfo {
	result := &pbTypes.CpuInfo{}

	result.CacheSize = c.CacheSize
	result.CoreId = c.CoreId
	result.Cores = c.Cores
	result.Cpu = c.Cpu
	result.Family = c.Family
	result.Mhz = c.Mhz
	result.Microcode = c.Microcode
	result.Model = c.Model
	result.ModelName = c.ModelName
	result.PhysicalId = c.PhysicalId
	result.Stepping = c.Stepping
	result.VendorId = c.VendorId
	return result
}

// DiskUsage is a data for DiskUsage without internal locks
type DiskUsage struct {
	Free        uint64  `json:"free,omitempty"`
	Fstype      string  `json:"fstype,omitempty"`
	Path        string  `json:"path,omitempty"`
	Total       uint64  `json:"total,omitempty"`
	Used        uint64  `json:"used,omitempty"`
	UsedPercent float32 `json:"used_percent,omitempty"`
}

// FromDiskUsage creates a DiskUsage from DiskUsage
func FromDiskUsage(src *pbTypes.DiskUsage) DiskUsage {
	if src == nil {
		return DiskUsage{}
	}

	result := DiskUsage{}
	result.Free = src.GetFree()
	result.Fstype = src.GetFstype()
	result.Path = src.GetPath()
	result.Total = src.GetTotal()
	result.Used = src.GetUsed()
	result.UsedPercent = src.GetUsedPercent()
	return result
}

// ToDiskUsage converts DiskUsage to DiskUsage
func (d DiskUsage) ToDiskUsage() *pbTypes.DiskUsage {
	result := &pbTypes.DiskUsage{}

	result.Free = d.Free
	result.Fstype = d.Fstype
	result.Path = d.Path
	result.Total = d.Total
	result.Used = d.Used
	result.UsedPercent = d.UsedPercent
	return result
}

// HostInfo is a data for HostInfo without internal locks
type HostInfo struct {
	Hostname        string `json:"hostname,omitempty"`
	KernelArch      string `json:"kernel_arch,omitempty"`
	KernelVersion   string `json:"kernel_version,omitempty"`
	Os              string `json:"os,omitempty"`
	Platform        string `json:"platform,omitempty"`
	PlatformFamily  string `json:"platform_family,omitempty"`
	PlatformVersion string `json:"platform_version,omitempty"`
}

// FromHostInfo creates a HostInfo from HostInfo
func FromHostInfo(src *pbTypes.HostInfo) HostInfo {
	if src == nil {
		return HostInfo{}
	}

	result := HostInfo{}
	result.Hostname = src.GetHostname()
	result.KernelArch = src.GetKernelArch()
	result.KernelVersion = src.GetKernelVersion()
	result.Os = src.GetOs()
	result.Platform = src.GetPlatform()
	result.PlatformFamily = src.GetPlatformFamily()
	result.PlatformVersion = src.GetPlatformVersion()
	return result
}

// ToHostInfo converts HostInfo to HostInfo
func (h HostInfo) ToHostInfo() *pbTypes.HostInfo {
	result := &pbTypes.HostInfo{}

	result.Hostname = h.Hostname
	result.KernelArch = h.KernelArch
	result.KernelVersion = h.KernelVersion
	result.Os = h.Os
	result.Platform = h.Platform
	result.PlatformFamily = h.PlatformFamily
	result.PlatformVersion = h.PlatformVersion
	return result
}

// MemoryInfo is a data for MemoryInfo without internal locks
type MemoryInfo struct {
	Available   uint64  `json:"available,omitempty"`
	Total       uint64  `json:"total,omitempty"`
	Used        uint64  `json:"used,omitempty"`
	UsedPercent float32 `json:"used_percent,omitempty"`
}

// FromMemoryInfo creates a MemoryInfo from MemoryInfo
func FromMemoryInfo(src *pbTypes.MemoryInfo) MemoryInfo {
	if src == nil {
		return MemoryInfo{}
	}

	result := MemoryInfo{}
	result.Available = src.GetAvailable()
	result.Total = src.GetTotal()
	result.Used = src.GetUsed()
	result.UsedPercent = src.GetUsedPercent()
	return result
}

// ToMemoryInfo converts MemoryInfo to MemoryInfo
func (m MemoryInfo) ToMemoryInfo() *pbTypes.MemoryInfo {
	result := &pbTypes.MemoryInfo{}

	result.Available = m.Available
	result.Total = m.Total
	result.Used = m.Used
	result.UsedPercent = m.UsedPercent
	return result
}

// NetworkInterface is a data for NetworkInterface without internal locks
type NetworkInterface struct {
	Addrs []string `json:"addrs,omitempty"`
	Flags []string `json:"flags,omitempty"`
	Name  string   `json:"name,omitempty"`
}

// FromNetworkInterface creates a NetworkInterface from NetworkInterface
func FromNetworkInterface(src *pbTypes.NetworkInterface) NetworkInterface {
	if src == nil {
		return NetworkInterface{}
	}

	result := NetworkInterface{}
	result.Addrs = src.GetAddrs()
	result.Flags = src.GetFlags()
	result.Name = src.GetName()
	return result
}

// ToNetworkInterface converts NetworkInterface to NetworkInterface
func (n NetworkInterface) ToNetworkInterface() *pbTypes.NetworkInterface {
	result := &pbTypes.NetworkInterface{}

	result.Addrs = n.Addrs
	result.Flags = n.Flags
	result.Name = n.Name
	return result
}

// Node is a data for Node without internal locks
type Node struct {
	Address    string         `json:"address,omitempty"`
	CreatedAt  time.Time      `json:"created_at,omitempty"`
	Definition NodeDefinition `json:"definition,omitempty"`
	Location   string         `json:"location,omitempty"`
	Name       string         `json:"name,omitempty"`
	Pubkey     []byte         `json:"pubkey,omitempty"`
	Uid        uuid.UUID      `json:"uid,omitempty"`
	UpdatedAt  time.Time      `json:"updated_at,omitempty"`
}

// FromNode creates a Node from Node
func FromNode(src *pbTypes.Node) Node {
	if src == nil {
		return Node{}
	}

	result := Node{}
	result.Address = src.GetAddress()
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	if src.GetDefinition() != nil {
		result.Definition = FromNodeDefinition(src.GetDefinition())
	}
	result.Location = src.GetLocation()
	result.Name = src.GetName()
	result.Pubkey = src.GetPubkey()
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	if src.GetUpdatedAt() != nil {
		result.UpdatedAt = src.GetUpdatedAt().AsTime()
	}
	return result
}

// ToNode converts Node to Node
func (n Node) ToNode() *pbTypes.Node {
	result := &pbTypes.Node{}

	result.Address = n.Address
	result.CreatedAt = timestamppb.New(n.CreatedAt)
	result.Definition = n.Definition.ToNodeDefinition()
	result.Location = n.Location
	result.Name = n.Name
	result.Pubkey = n.Pubkey
	result.Uid = n.Uid.String()
	result.UpdatedAt = timestamppb.New(n.UpdatedAt)
	return result
}

// NodeDefinition is a data for NodeDefinition without internal locks
type NodeDefinition struct {
	Cpu    []CpuInfo            `json:"cpu,omitempty"`
	Disks  map[string]DiskUsage `json:"disks,omitempty"`
	Host   HostInfo             `json:"host,omitempty"`
	Memory MemoryInfo           `json:"memory,omitempty"`
	Nets   []NetworkInterface   `json:"nets,omitempty"`
}

// FromNodeDefinition creates a NodeDefinition from NodeDefinition
func FromNodeDefinition(src *pbTypes.NodeDefinition) NodeDefinition {
	if src == nil {
		return NodeDefinition{}
	}

	result := NodeDefinition{}
	for _, item := range src.GetCpu() {
		if item != nil {
			result.Cpu = append(result.Cpu, FromCpuInfo(item))
		}
	}
	// Convert map field disks
	if src.GetDisks() != nil {
		result.Disks = make(map[string]DiskUsage)
		for k, v := range src.GetDisks() {
			if v != nil {
				result.Disks[k] = FromDiskUsage(v)
			}
		}
	}
	if src.GetHost() != nil {
		result.Host = FromHostInfo(src.GetHost())
	}
	if src.GetMemory() != nil {
		result.Memory = FromMemoryInfo(src.GetMemory())
	}
	for _, item := range src.GetNets() {
		if item != nil {
			result.Nets = append(result.Nets, FromNetworkInterface(item))
		}
	}
	return result
}

// ToNodeDefinition converts NodeDefinition to NodeDefinition
func (n NodeDefinition) ToNodeDefinition() *pbTypes.NodeDefinition {
	result := &pbTypes.NodeDefinition{}

	for _, item := range n.Cpu {
		result.Cpu = append(result.Cpu, item.ToCpuInfo())
	}
	// Convert map field disks
	if n.Disks != nil {
		result.Disks = make(map[string]*pbTypes.DiskUsage)
		for k, v := range n.Disks {
			result.Disks[k] = v.ToDiskUsage()
		}
	}
	result.Host = n.Host.ToHostInfo()
	result.Memory = n.Memory.ToMemoryInfo()
	for _, item := range n.Nets {
		result.Nets = append(result.Nets, item.ToNetworkInterface())
	}
	return result
}
