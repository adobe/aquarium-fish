/**
 * Copyright 2025 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

// Code generated by Aquarium buf-gen-pb-data. DO NOT EDIT.

package aquariumv2

import (
	"encoding/json"

	"time"

	"github.com/google/uuid"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/structpb"

	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/adobe/aquarium-fish/lib/util"

	pbTypes "github.com/adobe/aquarium-fish/lib/rpc/proto/aquarium/v2"
)

// ApplicationState_Status mirrors the protobuf enum
type ApplicationState_Status int32

const (
	ApplicationState_ALLOCATED   ApplicationState_Status = 3
	ApplicationState_DEALLOCATE  ApplicationState_Status = 4
	ApplicationState_DEALLOCATED ApplicationState_Status = 5
	ApplicationState_ELECTED     ApplicationState_Status = 2
	ApplicationState_ERROR       ApplicationState_Status = 6
	ApplicationState_NEW         ApplicationState_Status = 1
	ApplicationState_UNSPECIFIED ApplicationState_Status = 0
)

type ApplicationResourceUID = uuid.UUID
type ApplicationStateUID = uuid.UUID
type ApplicationTaskUID = uuid.UUID
type ApplicationUID = uuid.UUID

// Application is a data for Application without internal locks
type Application struct {
	CreatedAt time.Time         `json:"created_at,omitempty"`
	LabelUid  uuid.UUID         `json:"label_uid,omitempty"`
	Metadata  util.UnparsedJSON `json:"metadata,omitempty"`
	OwnerName string            `json:"owner_name,omitempty"`
	Uid       uuid.UUID         `json:"uid,omitempty"`
}

// FromApplication creates a Application from Application
func FromApplication(src *pbTypes.Application) Application {
	if src == nil {
		return Application{}
	}

	result := Application{}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	if uid, err := uuid.Parse(src.GetLabelUid()); err == nil {
		result.LabelUid = uid
	}
	if src.GetMetadata() != nil {
		if data, err := protojson.Marshal(src.GetMetadata()); err == nil {
			result.Metadata = util.UnparsedJSON(data)
		}
	} else {
		result.Metadata = util.UnparsedJSON("{}")
	}
	result.OwnerName = src.GetOwnerName()
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	return result
}

// ToApplication converts Application to Application
func (a Application) ToApplication() *pbTypes.Application {
	result := &pbTypes.Application{}

	result.CreatedAt = timestamppb.New(a.CreatedAt)
	result.LabelUid = a.LabelUid.String()
	var mapData map[string]any
	if err := json.Unmarshal([]byte(a.Metadata), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Metadata = structData
		}
	}
	result.OwnerName = a.OwnerName
	result.Uid = a.Uid.String()
	return result
}

// ApplicationResource is a data for ApplicationResource without internal locks
type ApplicationResource struct {
	ApplicationUid  uuid.UUID         `json:"application_uid,omitempty"`
	Authentication  *Authentication   `json:"authentication,omitempty"`
	CreatedAt       time.Time         `json:"created_at,omitempty"`
	DefinitionIndex int32             `json:"definition_index,omitempty"`
	HwAddr          string            `json:"hw_addr,omitempty"`
	Identifier      string            `json:"identifier,omitempty"`
	IpAddr          string            `json:"ip_addr,omitempty"`
	LabelUid        uuid.UUID         `json:"label_uid,omitempty"`
	Metadata        util.UnparsedJSON `json:"metadata,omitempty"`
	NodeUid         uuid.UUID         `json:"node_uid,omitempty"`
	Timeout         *time.Time        `json:"timeout,omitempty"`
	Uid             uuid.UUID         `json:"uid,omitempty"`
	UpdatedAt       time.Time         `json:"updated_at,omitempty"`
}

// FromApplicationResource creates a ApplicationResource from ApplicationResource
func FromApplicationResource(src *pbTypes.ApplicationResource) ApplicationResource {
	if src == nil {
		return ApplicationResource{}
	}

	result := ApplicationResource{}
	if uid, err := uuid.Parse(src.GetApplicationUid()); err == nil {
		result.ApplicationUid = uid
	}
	if src.GetAuthentication() != nil {
		data := FromAuthentication(src.GetAuthentication())
		result.Authentication = &data
	}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	result.DefinitionIndex = src.GetDefinitionIndex()
	result.HwAddr = src.GetHwAddr()
	result.Identifier = src.GetIdentifier()
	result.IpAddr = src.GetIpAddr()
	if uid, err := uuid.Parse(src.GetLabelUid()); err == nil {
		result.LabelUid = uid
	}
	if src.GetMetadata() != nil {
		if data, err := protojson.Marshal(src.GetMetadata()); err == nil {
			result.Metadata = util.UnparsedJSON(data)
		}
	} else {
		result.Metadata = util.UnparsedJSON("{}")
	}
	if uid, err := uuid.Parse(src.GetNodeUid()); err == nil {
		result.NodeUid = uid
	}
	if src.GetTimeout() != nil {
		t := src.GetTimeout().AsTime()
		result.Timeout = &t
	}
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	if src.GetUpdatedAt() != nil {
		result.UpdatedAt = src.GetUpdatedAt().AsTime()
	}
	return result
}

// ToApplicationResource converts ApplicationResource to ApplicationResource
func (a ApplicationResource) ToApplicationResource() *pbTypes.ApplicationResource {
	result := &pbTypes.ApplicationResource{}

	result.ApplicationUid = a.ApplicationUid.String()
	if a.Authentication != nil {
		result.Authentication = a.Authentication.ToAuthentication()
	}
	result.CreatedAt = timestamppb.New(a.CreatedAt)
	result.DefinitionIndex = a.DefinitionIndex
	result.HwAddr = a.HwAddr
	result.Identifier = a.Identifier
	result.IpAddr = a.IpAddr
	result.LabelUid = a.LabelUid.String()
	var mapData map[string]any
	if err := json.Unmarshal([]byte(a.Metadata), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Metadata = structData
		}
	}
	result.NodeUid = a.NodeUid.String()
	if a.Timeout != nil {
		result.Timeout = timestamppb.New(*a.Timeout)
	}
	result.Uid = a.Uid.String()
	result.UpdatedAt = timestamppb.New(a.UpdatedAt)
	return result
}

// ApplicationState is a data for ApplicationState without internal locks
type ApplicationState struct {
	ApplicationUid uuid.UUID               `json:"application_uid,omitempty"`
	CreatedAt      time.Time               `json:"created_at,omitempty"`
	Description    string                  `json:"description,omitempty"`
	Status         ApplicationState_Status `json:"status,omitempty"`
	Uid            uuid.UUID               `json:"uid,omitempty"`
}

// FromApplicationState creates a ApplicationState from ApplicationState
func FromApplicationState(src *pbTypes.ApplicationState) ApplicationState {
	if src == nil {
		return ApplicationState{}
	}

	result := ApplicationState{}
	if uid, err := uuid.Parse(src.GetApplicationUid()); err == nil {
		result.ApplicationUid = uid
	}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	result.Description = src.GetDescription()
	// Convert enum field
	result.Status = ApplicationState_Status(src.GetStatus())
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	return result
}

// ToApplicationState converts ApplicationState to ApplicationState
func (a ApplicationState) ToApplicationState() *pbTypes.ApplicationState {
	result := &pbTypes.ApplicationState{}

	result.ApplicationUid = a.ApplicationUid.String()
	result.CreatedAt = timestamppb.New(a.CreatedAt)
	result.Description = a.Description
	// Convert enum field back to pbTypes
	result.Status = pbTypes.ApplicationState_Status(a.Status)
	result.Uid = a.Uid.String()
	return result
}

// ApplicationTask is a data for ApplicationTask without internal locks
type ApplicationTask struct {
	ApplicationUid uuid.UUID               `json:"application_uid,omitempty"`
	CreatedAt      time.Time               `json:"created_at,omitempty"`
	Options        util.UnparsedJSON       `json:"options,omitempty"`
	Result         util.UnparsedJSON       `json:"result,omitempty"`
	Task           string                  `json:"task,omitempty"`
	Uid            uuid.UUID               `json:"uid,omitempty"`
	UpdatedAt      time.Time               `json:"updated_at,omitempty"`
	When           ApplicationState_Status `json:"when,omitempty"`
}

// FromApplicationTask creates a ApplicationTask from ApplicationTask
func FromApplicationTask(src *pbTypes.ApplicationTask) ApplicationTask {
	if src == nil {
		return ApplicationTask{}
	}

	result := ApplicationTask{}
	if uid, err := uuid.Parse(src.GetApplicationUid()); err == nil {
		result.ApplicationUid = uid
	}
	if src.GetCreatedAt() != nil {
		result.CreatedAt = src.GetCreatedAt().AsTime()
	}
	if src.GetOptions() != nil {
		if data, err := protojson.Marshal(src.GetOptions()); err == nil {
			result.Options = util.UnparsedJSON(data)
		}
	} else {
		result.Options = util.UnparsedJSON("{}")
	}
	if src.GetResult() != nil {
		if data, err := protojson.Marshal(src.GetResult()); err == nil {
			result.Result = util.UnparsedJSON(data)
		}
	} else {
		result.Result = util.UnparsedJSON("{}")
	}
	result.Task = src.GetTask()
	if uid, err := uuid.Parse(src.GetUid()); err == nil {
		result.Uid = uid
	}
	if src.GetUpdatedAt() != nil {
		result.UpdatedAt = src.GetUpdatedAt().AsTime()
	}
	// Convert enum field
	result.When = ApplicationState_Status(src.GetWhen())
	return result
}

// ToApplicationTask converts ApplicationTask to ApplicationTask
func (a ApplicationTask) ToApplicationTask() *pbTypes.ApplicationTask {
	result := &pbTypes.ApplicationTask{}

	result.ApplicationUid = a.ApplicationUid.String()
	result.CreatedAt = timestamppb.New(a.CreatedAt)
	var mapData map[string]any
	if err := json.Unmarshal([]byte(a.Options), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Options = structData
		}
	}
	if err := json.Unmarshal([]byte(a.Result), &mapData); err == nil {
		if structData, err := structpb.NewStruct(mapData); err == nil {
			result.Result = structData
		}
	}
	result.Task = a.Task
	result.Uid = a.Uid.String()
	result.UpdatedAt = timestamppb.New(a.UpdatedAt)
	// Convert enum field back to pbTypes
	result.When = pbTypes.ApplicationState_Status(a.When)
	return result
}
