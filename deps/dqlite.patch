diff --git a/src/gateway.c b/src/gateway.c
index 40944f9..216fb93 100644
--- a/src/gateway.c
+++ b/src/gateway.c
@@ -581,6 +581,7 @@ static int handle_add(struct handle *req, struct cursor *cursor)
 	}
 	r->gateway = g;
 	r->req.data = r;
+	g->req = req;
 
 	rv = raft_add(g->raft, &r->req, request.id, request.address,
 		      raftChangeCb);
@@ -589,7 +590,6 @@ static int handle_add(struct handle *req, struct cursor *cursor)
 		failure(req, translateRaftErrCode(rv), raft_strerror(rv));
 		return 0;
 	}
-	g->req = req;
 
 	return 0;
 }
@@ -637,6 +637,7 @@ static int handle_assign(struct handle *req, struct cursor *cursor)
 	}
 	r->gateway = g;
 	r->req.data = r;
+	g->req = req;
 
 	rv = raft_assign(g->raft, &r->req, request.id,
 			 translateDqliteRole((int)role), raftChangeCb);
@@ -645,7 +646,6 @@ static int handle_assign(struct handle *req, struct cursor *cursor)
 		failure(req, translateRaftErrCode(rv), raft_strerror(rv));
 		return 0;
 	}
-	g->req = req;
 
 	return 0;
 }
@@ -666,6 +666,7 @@ static int handle_remove(struct handle *req, struct cursor *cursor)
 	}
 	r->gateway = g;
 	r->req.data = r;
+	g->req = req;
 
 	rv = raft_remove(g->raft, &r->req, request.id, raftChangeCb);
 	if (rv != 0) {
@@ -673,7 +674,6 @@ static int handle_remove(struct handle *req, struct cursor *cursor)
 		failure(req, translateRaftErrCode(rv), raft_strerror(rv));
 		return 0;
 	}
-	g->req = req;
 
 	return 0;
 }
@@ -902,6 +902,7 @@ static int handle_transfer(struct handle *req, struct cursor *cursor)
 		return DQLITE_NOMEM;
 	}
 	r->data = g;
+	g->req = req;
 
 	rv = raft_transfer(g->raft, r, request.id, raftTransferCb);
 	if (rv != 0) {
@@ -909,7 +910,6 @@ static int handle_transfer(struct handle *req, struct cursor *cursor)
 		failure(req, translateRaftErrCode(rv), raft_strerror(rv));
 		return 0;
 	}
-	g->req = req;
 
 	return 0;
 }
diff --git a/src/server.c b/src/server.c
index 990ba75..4c6cac8 100644
--- a/src/server.c
+++ b/src/server.c
@@ -69,6 +69,10 @@ int dqlite__init(struct dqlite_node *d,
 	raft_set_pre_vote(&d->raft, true);
 	raft_set_max_catch_up_rounds(&d->raft, 100);
 	raft_set_max_catch_up_round_duration(&d->raft, 50 * 1000); /* 50 secs */
+#ifdef __APPLE__
+	d->ready = dispatch_semaphore_create(0);
+	d->stopped = dispatch_semaphore_create(0);
+#else
 	rv = sem_init(&d->ready, 0, 0);
 	if (rv != 0) {
 		/* TODO: better error reporting */
@@ -81,6 +85,7 @@ int dqlite__init(struct dqlite_node *d,
 		rv = DQLITE_ERROR;
 		goto err_after_ready_init;
 	}
+#endif
 
 	rv = pthread_mutex_init(&d->mutex, NULL);
 	assert(rv == 0); /* Docs say that pthread_mutex_init can't fail */
@@ -92,7 +97,11 @@ int dqlite__init(struct dqlite_node *d,
 	return 0;
 
 err_after_ready_init:
+#ifdef __APPLE__
+	dispatch_release(d->ready);
+#else
 	sem_destroy(&d->ready);
+#endif
 err_after_raft_fsm_init:
 	fsm__close(&d->raft_fsm);
 err_after_raft_io_init:
@@ -115,10 +124,15 @@ void dqlite__close(struct dqlite_node *d)
 	raft_free(d->listener);
 	rv = pthread_mutex_destroy(&d->mutex); /* This is a no-op on Linux . */
 	assert(rv == 0);
+#ifdef __APPLE__
+	dispatch_release(d->stopped);
+	dispatch_release(d->ready);
+#else
 	rv = sem_destroy(&d->stopped);
 	assert(rv == 0); /* Fails only if sem object is not valid */
 	rv = sem_destroy(&d->ready);
 	assert(rv == 0); /* Fails only if sem object is not valid */
+#endif
 	fsm__close(&d->raft_fsm);
 	uv_loop_close(&d->loop);
 	raftProxyClose(&d->raft_transport);
@@ -203,15 +217,28 @@ int dqlite_node_set_bind_address(dqlite_node *t, const char *address)
 			/* Auto bind */
 			len = 0;
 		} else {
-			strcpy(addr_un.sun_path + 1, address + 1);
+#if defined(__linux__)
+			// Linux abstract socket requires \0 in sun_path[0]
+			strncat(addr_un.sun_path + 1, address + 1, sizeof(addr_un.sun_path) - 1);
+#else
+			// MacOS do not support abstract sockets
+			strncat(addr_un.sun_path, address + 1, sizeof(addr_un.sun_path));
+			(void)unlink(addr_un.sun_path);
+#endif
 		}
 		len += sizeof(sa_family_t);
 		addr = (struct sockaddr *)&addr_un;
 	}
-	fd = socket(domain, SOCK_STREAM | SOCK_CLOEXEC, 0);
+	fd = socket(domain, SOCK_STREAM, 0);
 	if (fd == -1) {
 		return DQLITE_ERROR;
 	}
+	rv = fcntl(fd, FD_CLOEXEC);
+	if (rv != 0) {
+		close(fd);
+		return DQLITE_ERROR;
+	}
+
 	if (domain == AF_INET) {
 		int reuse = 1;
 		rv = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
@@ -323,6 +350,8 @@ static int maybeBootstrap(dqlite_node *d,
 		if (rv == RAFT_CANTBOOTSTRAP) {
 			rv = 0;
 		} else {
+			snprintf(d->errmsg, RAFT_ERRMSG_BUF_SIZE, "raft_bootstrap(): %s",
+				 raft_errmsg(&d->raft));
 			rv = DQLITE_ERROR;
 		}
 		goto out;
@@ -380,8 +409,12 @@ static void startup_cb(uv_timer_t *startup)
 	struct dqlite_node *d = startup->data;
 	int rv;
 	d->running = true;
+#ifdef __APPLE__
+	dispatch_semaphore_signal(d->ready);
+#else
 	rv = sem_post(&d->ready);
 	assert(rv == 0); /* No reason for which posting should fail */
+#endif
 }
 
 static void listenCb(uv_stream_t *listener, int status)
@@ -425,11 +458,10 @@ static void listenCb(uv_stream_t *listener, int status)
 
 	/* We accept unix socket connections only from the same process. */
 	if (listener->type == UV_NAMED_PIPE) {
+		int fd = stream->io_watcher.fd;
+#if defined(SO_PEERCRED)
 		struct ucred cred;
-		socklen_t len;
-		int fd;
-		fd = stream->io_watcher.fd;
-		len = sizeof cred;
+		socklen_t len = sizeof(cred);
 		rv = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cred, &len);
 		if (rv != 0) {
 			goto err;
@@ -437,6 +469,17 @@ static void listenCb(uv_stream_t *listener, int status)
 		if (cred.pid != getpid()) {
 			goto err;
 		}
+#elif defined(LOCAL_PEERPID)
+		pid_t pid = -1;
+		socklen_t len = sizeof(pid);
+		rv = getsockopt(fd, SOL_LOCAL, LOCAL_PEERPID, &pid, &len);
+		if (rv != 0) {
+			goto err;
+		}
+		if (pid != getpid()) {
+			goto err;
+		}
+#endif
 	}
 
 	conn = sqlite3_malloc(sizeof *conn);
@@ -492,7 +535,11 @@ static int taskRun(struct dqlite_node *d)
 		snprintf(d->errmsg, RAFT_ERRMSG_BUF_SIZE, "raft_start(): %s",
 			 raft_errmsg(&d->raft));
 		/* Unblock any client of taskReady */
+#ifdef __APPLE__
+		dispatch_semaphore_signal(d->ready);
+#else
 		sem_post(&d->ready);
+#endif
 		return rv;
 	}
 
@@ -500,8 +547,12 @@ static int taskRun(struct dqlite_node *d)
 	assert(rv == 0);
 
 	/* Unblock any client of taskReady */
+#ifdef __APPLE__
+	dispatch_semaphore_signal(d->ready);
+#else
 	rv = sem_post(&d->ready);
 	assert(rv == 0); /* no reason for which posting should fail */
+#endif
 
 	return 0;
 }
@@ -539,7 +590,11 @@ void dqlite_node_destroy(dqlite_node *d)
 static bool taskReady(struct dqlite_node *d)
 {
 	/* Wait for the ready semaphore */
+#ifdef __APPLE__
+	dispatch_semaphore_wait(d->ready, DISPATCH_TIME_FOREVER);
+#else
 	sem_wait(&d->ready);
+#endif
 	return d->running;
 }
 
diff --git a/src/server.h b/src/server.h
index 3e1c99d..2086106 100644
--- a/src/server.h
+++ b/src/server.h
@@ -2,6 +2,12 @@
 #include <raft/uv.h>
 #include <sqlite3.h>
 
+#ifdef __APPLE__
+#include <dispatch/dispatch.h>
+#else
+#include <semaphore.h>
+#endif
+
 #include "config.h"
 #include "lib/assert.h"
 #include "logger.h"
@@ -20,8 +26,13 @@ struct dqlite_node
 	struct raft_uv_transport raft_transport;    /* Raft libuv transport */
 	struct raft_io raft_io;                     /* libuv I/O */
 	struct raft_fsm raft_fsm;                   /* dqlite FSM */
+#ifdef __APPLE__
+	dispatch_semaphore_t ready;                 /* Server is ready */
+	dispatch_semaphore_t stopped;               /* Notifiy loop stopped */
+#else
 	sem_t ready;                                /* Server is ready */
 	sem_t stopped;                              /* Notifiy loop stopped */
+#endif
 	pthread_mutex_t mutex;                      /* Access incoming queue */
 	queue queue;                                /* Incoming connections */
 	queue conns;                                /* Active connections */
